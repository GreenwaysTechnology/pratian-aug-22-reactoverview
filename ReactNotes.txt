				 React
..............................................................................................

What is React?

  React is javascript lib for building single page web apps.

React java script lib like jquery,framework like angular.


What is User interface application?
 
  The user where he interacts , those applications are called user interface applications.

Eg:
  Desktop applications
     if you want to interact with os, shell is primary user interface
     shell in windows, command,powershell,explorer 

  Web Browser:
     It is one of the application software, acts as user interface for web applications

 
 Hand Held devices
  =>Mobile applications
  =>Watch
  =>Tabs
 etc..

Types of web app


1.static web apps -  1989 to 1995
    built at server end,accessed by clients using browser

2.dynamic content web apps - 1996 to till date
    built at server end, access by clients using browser
eg:
  JEE(Servlets,jsp)
  Asp.net
  PHP
 etc.....

3.Web Services -1998 to till
     built at server end, accessed by clients  such  as mobiles, client side browser apps.
 SOAP,RESTFull

4.Single Page Web Apps -  2007 to till date
   built at client side,accessed by clients browsers.
  built using javascript,html 5,css 3 
Frameworks and libs
 ->Angular js -  Angular 2 - 
 ->React.js - 2013 by facebook

............................................................................................
				     React

   "React is modern SPA lib created by face book based on "Flux Design Pattern"


Architecture for libs and frameworks:
Plain JS
			 Application(dom) -plain js
			     |
			 Javascript Engine
			      |
			 Browser Engine




Framework/lib
			 Application(JQuery)
			     |
		       ---------------------------
			  JQuery Engine	------javascript programming		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine



What is jquery engine?
  Jquery engine is also javascript program.




Angular
			 Application(Angular)
			     |
		       ---------------------------
			  Angular Engine : Renderer(Ng2) Renderer2(Ng4,5),Ivy(6,7)		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine

React


		       Application(React)
			     |
		       ---------------------------
	              React Engine :React fiber-->React 16 on wards		
                       -------------------------------
			      |
			 Javascript Engine
			      |
			  Browser Engine


				React Future
..............................................................................................

React was built by face book only for web browsers, later facebook decided to scale react for building other types of user application (mobile,iot applications).

React can be used to build application for 
........................................
1.browsers : Desktop -  react js
2.Mobile Apps : React Native

face book is working on many futures projects related to react
3.React VR : Virtual Reality.
4.React Car : For car applications
5.React TV  : React for TV.
6.React IOT : any devices
.............................................................................................
				Setup React Project
..............................................................................................

Create React App - tool to setup project
https://create-react-app.dev/

Two ways of setting project 

via npm global modules
via npx modules

via npm:

Install tool:

open cmd:

install tool first

npm install create-react-app -g

create a app
create-react-app my-app

Create project directly without installing create-react-app tool

npx create-react-app my-app

............................................................................................

			React Project layout- created by create-react-app
.............................................................................................

Folder Structure

myapp
 |
 node_modules
 package.json
 package-lock.json
 public 
 src
 readme.md


node_modules
  It is folder contains all libs files and folders downloaded from internet.
  React lib has been downloaded and kept inside this folder only.

package.json
   Every javascript project(it can be any js project), has package.json file  
   This file contains information about the project

Basic information:
 ->Name of the application "name" :"myapp"
 ->version of the application "version": "1.0.0"
 ->dedendencies
     libs  required for dev ,testing, production
    you can understand what version of lib is used in the current project
 ->scripts
     scripts contains information about how to start dev server,testing,production build.

package-lock.json:
  This file used by dev ops tools.


public 
  index.html
  This is entry file in react application.
  without this file we cant start the application

src
 |
 index.js
  App.js
 This folder contains application code files.

readme.md
   this is documentation file
..............................................................................................
				  HTML

HTML is core language for building any type of web apps.

static - html page is created at server and sent to browsers
dynamic -  html page is created at server by the programs on fly,sent to browser
spa - html page is created at client side on fly and rendered in the client itself using javascript.

			   DOM programming 

What is DOM?
  Document Object model, which is spec to build and modify html pages on fly.

Object oriented HTML, HTML elements are represented as objects.

eg:
 H1 - Object
div - Object
 p  - Object

DOM helps to create DOM onfly to attach on existing document
..........................................................................................
				HTML works internally
.............................................................................................

HTML:

1.HTML IS PL? - YES
2.HTML Is compiled -YES
3.HTML is excuted-YES

java
 -source .java
 -compile -.class -assembly
 -excute -jvm--result

index.html -source code
  html code is organized as hierachal model -  hierachial datastructure
<html>
<head></head>
<title><title>
<body>
  <div>
     <h1>Welcome</h1>
  </div>
</body>
</html>

Layout/Paint Engine: will convert nodes into pxs : final output
..............................................................................................
				Dynamic HTML - Inside Web Browser
.............................................................................................

Once the html has been rendered by the web browser, can we change the html(adding new element,updating existing element content,removing node,listing nodes).

The company called Netscap communcation, the second web browser creator after line mode web browser.

The NetsCap communication introduced the browser called netscap navigator , today firefox.

The netscap introduced a new technology called how to change html after rendering.

In 1996,Netscap communication,Started an RND project called "How to manipulate the tree"

Tree is written in c language,then we need another c program to communicate.

But NETSCAP decided not to use C pl.

Netscap wanted to put java like implementation inside browser to manipulate "Tree".

                        "The birth of Javascript"

How to access nodes from javascript engine?
  
One spec was published ,As per that spec
 "Document Object Model"
    -How to represent document(elements/nodes) in object oriented way.->DOM

 "Documents can be reprsented as Objects" : Object oriented Document Programming.
............................................................................................
How dom works?

index.html           Broser runtime(C program)         Javascript Engine
<h1>Hello</h1>       h1-Node                           h1- Object
			Hello-Node			 Hello Object Property



                 Every Html ELEMENT Inside Browser is "C Program"

	       Every Html ELEMENT javascript engine is "Object"


javascript developer ---->uses api --->to communicate Object---->js engine---->browser engine.	*******************************************************************************************	

Who and when "H1" object is created?

if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()


<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?



if you want to create object?

 class/ function

function Employee(){}  let emp = new Employee()

<h1> => function HTMLHeadingElement(){} => let h =new HTMLHeadingElement() ?

Note: For html elements, we cant create object directly, rather than JS Engine will create objects , return references to the developer to access.

How via factory Objects: object helps to get other documents

Factory Object : HTML Document =>body

document.getElementById();
   |
Implicit object reference variable which points HTMLDocument OBject.


What is our objective here? DOM Programming?


Enter into DOM programming:

1.write dom programming using javascript language.

<body>
  |
HTMLDocument : body : factory Object


Document apis:

Finding HTML Elements:
......................

HTMLElement document.getElementById(id)	       Find an element by element id
HTMLElement Document document.getElementsByTagName(name)	Find elements by tag name
HTMLElement document.getElementsByClassName(name)	Find elements by class name
HTMLElement document.querySelectory(selector)        find element/elements by selector


Changing HTML Elements : update existing element
......................
element.innerHTML =  new html content	Change the inner HTML of an element
element.attribute = new value	Change the attribute value of an HTML element
element.style.property = new style	Change the style of an HTML element
Method	Description
element.setAttribute(attribute, value)	Change the attribute value of an HTML element

Adding and Deleting Elements:


document.createElement(element)	Create an HTML element
document.removeChild(element)	Remove an HTML element
document.appendChild(element)	Add an HTML element
document.replaceChild(new, old)	Replace an HTML element
.............................................................................................
				DOM Programming
.............................................................................................

How to implement dom programming?

1.using plain js
  if we use plain js , it is very difficult to build large applications

2.using frameworks and libs

2000 - The first javascript framework - DOJO
2002-2005 - JQuery - is the second most powerfull dom lib.
After 2006 - many js libs and frameworks introduced.....
..............................................................................................


Before 2007 - 

  HTML pages were created at server side, sent to the client , where jquery like javascript libs and frameworks were introduced to change the rendered html.
 After introduction of REST Full web services, Technology was changed.
 
 =>Server side programs only render data(json/xml) - REST APIS
 =>client side technology uses data json, where to create html pages.

                   "The birth of new Web App  - SPA - Single Web Application"

=SPA  is new Web Application introduced by "W3C"   as part of new HTML Spec.

SPA Tech Stack:
1.HTML 5
2.CSS 3
3.Javascript
4.AJAX

SPA is client side web application.
 =>creates html pages on the browser itself by getting data from the server via ajax.

2008 - Angular js framework was introduced
   The first MVC based SPA Framework
............................................................................................
				     Modern web

In the client side is SPA , server side REST 
In the server SPA can be prepared , sent to the client- Server side rendering
..............................................................................................


Before 2007 - 

  HTML pages were created at server side, sent to the client , where jquery like javascript libs and frameworks were introduced to change the rendered html.
 After introduction of REST Full web services, Technology was changed.
 
 =>Server side programs only render data(json/xml) - REST APIS
 =>client side technology uses data json, where to create html pages.

                   "The birth of new Web App  - SPA - Single Web Application"

=SPA  is new Web Application introduced by "W3C"   as part of new HTML Spec.

SPA Tech Stack:
1.HTML 5
2.CSS 3
3.Javascript
4.AJAX

SPA is client side web application.
 =>creates html pages on the browser itself by getting data from the server via ajax.

2008 - Angular js framework was introduced
   The first MVC based SPA Framework
............................................................................................
............................................................................................
.............................................................................................
.............................................................................................
			How to create dom node , attach on existing tree
				using plain js

				
Note : 
 index.js

//How to create simple element using plain javascript

function createElement() {
    let Heading = document.createElement('h1')
    console.log(Heading)
    Heading.innerHTML = "Hello React!"
    let rootElement = document.getElementById('root')
    rootElement.appendChild(Heading)
}
createElement()
.............................................................................................
			How to create dom node , attach on existing tree
				using react.js


//dom element using react.
import React from 'react'
import ReactDOM from 'react-dom'

//  let Heading = document.createElement('h1')
const Heading = <h1>Hello React!!</h1>

//get element where you want to attach.
const rootElement = document.getElementById('root')

ReactDOM.render(Heading,rootElement)


The code above , we can see mixure of javascript and html.

How browser understands this code coimbination?

  The browser never understands this code directly.

What is this code is all about?
    
 Face book created a mini /small language for building react application - JSX language

..............................................................................................
				 Components
.............................................................................................

What is Component?
   Component  is nothing but "Object".

Component term introduced by MicroSoft in 1980s. According to Microsoft Component is object which is having "state(variables),behaviours(methods),User Interface(visual Representation)".

Component represents User Interface
Component is Object which represents User Interface.
User interface in browser is represented by HTML element or elements

Component can be represented some time , the object which helps to make up the Userinterface(invisible user interface).


element is <h1>Hello</h1>

elements are <div><div><h1>Hello</h1></div></div>

Plain Object:
 Object without ui is called plain object.
eg:
   function Employee() {
     this.id = 0;
     this.calculate=function(){}
   }

   new Employee()

DOM : Document Object Model
 
Document -  html
Object Model - Representation of HTML elements

Why We use Components model/Architecture?
  
=>Componets are independant objects.
=>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
 
Eg : 
 I am creating a component called "tax calculator".
 
lets say i want to use the tax calculator inside my hr application and inside my sale applcation , and purchase application.

..............................................................................................
				One Component is not a component
.............................................................................................
In large application, we create more components.
All components we coimbine to make up other big components or application.
Such wiring(connecting) components forms the structure called "component tree".

Component Tree:
   =>Object tree / DOM Tree / Virutal DOM Tree.
..............................................................................................
How to create Components in react?

We have three patterns.

1.Variable Pattern
2.function pattern
3.ES 6 class Pattern



//functions 
import React from 'react';
import ReactDOM from 'react-dom';

//create component using functions

// function Heading() {
//     return <h1>Hello!</h1> // jsx element 
// }

//es 6 arrow function 

// const Heading = () => {
//     return <h1>Hello!</h1> // jsx element 
// }
const Heading = () => <h1>Hello!</h1> // jsx element 

//imperative style of calling funciton : dont do this
// ReactDOM.render(Heading(), document.getElementById('root'))
//declarative style of calling function; you have to do this
ReactDOM.render(<Heading></Heading>, document.getElementById('root'))



import React from 'react';
import ReactDOM from 'react-dom';

//create component using  es 6 class

class Heading extends React.Component {

    render() {
        return <h1>Hello React!!!</h1>
    }
}



ReactDOM.render(<Heading></Heading>, document.getElementById('root'))


3.ES 6 class Pattern

Create Components Using ES 6 Class:
....................................

in order to create component  we need to inherit React.Component

React.Component is base class, which contains the follwing things

1.instance variables
 props
 state
2.instance methods

life cycle methods
 
to be discussed later
render() - Which returns ReactElement
 
other methods
to be discussed later

3.static variables
to be discussed later


Note: 
  Which pattern is good, or when to use?

 There is no pattern is bad or good.

 In case if react application is running old versions(before 16)

 =>class components 
     are used to mutate the state using setState method - statefull components
     Where ever you need life cycle methods
        
 =>function components are used to render ui and data - stateless components
 =>variable components are used just render static markup or tiny components used inside large   components.


 In case if react application is running new versions(After 16)

 functions and classes share the same behaviour
 functions can have state mutations, life cycle methods via a feature called "hooks".
 funcitional components are very powerfull with respect reuseability.

..............................................................................................	
				JSX Rules
..............................................................................................

JSX - Javascript and XML

What is JSX?
 JSX is dsl language to create user interfaces

What is relationship with XML?

 Inside JSX , we write javascript code and HTML code only not xml code.

Why the term XML is used?

 When we write JSX code, we need stable mark up standards.

You know very well HTML has weak parser  that means 
 <h1>hello
when run the code , the html parser does not stop rendering hello, it never throws any error

in order to avoid instability code inside jsx during compilation, JSX team adopted XML Parser rules, since XML parser has strong parser

Basic XML  rules:

1.every opened element must be closed
  <h1>Hello</h1>
  <Welcome></Welcome>
 some elements may not have closing tag
  <img /> : image element has no child elements : self closing. 

2. In xml you must have one single root element.
  all elements must be organized under single root element.

 <h1>Welcome to React</h1>
 <p>Path finder</p>

In html what can be root element
 <div>,<span>,all html 5 layout elements header,footer,section,aside...

3.Component names should start with Uppercase,generally would be noun.


eg:
import React from "react";
import ReactDOM from 'react-dom';

const Heading = ()=>{ 
    return <h1>Hello
}

ReactDOM.render(<Heading></Heading>, document.getElementById('root'));

src\index.js
  Line 8:35:  Parsing error: Unterminated JSX contents. (8:35)


Elements with no child : self closing.
import React from "react";
import ReactDOM from 'react-dom';

const Heading = ()=>{ 
    return <h1>Hello</h1>
}

//ReactDOM.render(<Heading></Heading>, document.getElementById('root'));
ReactDOM.render(<Heading/>, document.getElementById('root'));

..............................................................................................

import React from "react";
import ReactDOM from 'react-dom';

const Heading = ()=>{ 
    return <h1>Hello</h1>
            <h2>Sapient</h2>
}

//ReactDOM.render(<Heading></Heading>, document.getElementById('root'));
ReactDOM.render(<Heading/>, document.getElementById('root'));

 Parsing error: Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>? (6:12)

webpack 5.70.0 compiled with 2 errors in 41 ms

How to fix this problem?
  we need to wrap inside root/parent element.

What can be parent element?

  =>any html container  elements -  table,div,span,header,footer,address,nav
  =>you can use other components -  Tab,Dashboard....

.............
Right Code;
import React from "react";
import ReactDOM from 'react-dom';

const Heading = () => {
    return <div>
        <h1>Hello</h1>
        <h2>Sapient</h2>
    </div>
}

//ReactDOM.render(<Heading></Heading>, document.getElementById('root'));
ReactDOM.render(<Heading />, document.getElementById('root'));
..............................................................................................
Component names should start with Uppercase,generally would be noun.

import React from "react";
import ReactDOM from 'react-dom';

const heading = () => {
    return <div>
        <h1>Hello</h1>
        <h2>Sapient</h2>
    </div>
}

//ReactDOM.render(<Heading></Heading>, document.getElementById('root'));
ReactDOM.render(<heading />, document.getElementById('root'));

react-dom.development.js:67 Warning: The tag <heading> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.
    at heading

Here it wont throw any error,but it wont render any thing in the screen.
you can see warnings in the console. you have to fix it.  
..............................................................................................
..............................................................................................
				 How jsx code gets compiled?

How code gets compiled?

source code: jsx code

function Welcome() {
      return <h1>Welcome To React!</h1>;
}
	|
     babel.js - compiler 
|	
|
compiled code
function Welcome() {
  return React.createElement(
    'h1',
    null,
    'Welcome To React!'
  );
}
|
runtime : react engine
function Welcome() {
  return React.createElement(
    'h1',
    null,
    'Welcome To React!'
  );
}
|
//React.createElement
function createElement(args){
   document.createElement(args); // low level api call

..............................................................................................
..............................................................................................
				Component Composition
..............................................................................................

How to break large ui into smaller and smallar.

Why we need to create components?
 -Resuablity

DRY

How to create Component tree?

Layouts:

 Page
   Header
   Body 
   Footer


import React from "react";
import ReactDOM from 'react-dom';

const Link = () => <ul>
    <li><a href="letscreate">Let's Create</a></li>
    <li><a href="products">Products and Solutions</a></li>
    <li><a href="consulting">Consulting & Services</a></li>
    <li><a href="support">Learn & Support</a></li>
</ul>

const MenuBar = () => <nav>
        <Link/>
</nav>

//Header
const Header = () => <header>
    <h1>IBM -header</h1>
    <hr />
    <MenuBar />
</header>
//Body
const Body = () => <div>
    <p>
        International Business Machines Corporation (IBM) is an American multinational technology corporation headquartered in Armonk, New York, with operations in over 171 countries. The company began in 1911, founded in Endicott, New York, by trust businessman Charles Ranlett Flint, as the Computing-Tabulating-Recording Company (CTR) and was renamed "International Business Machines" in 1924. IBM is incorporated in New York
    </p>
</div>

//Footer 
const Footer = () => <header>
    <h1>IBM-Footer</h1>
</header>
//Page

//component linking
const Page = () => <div>
    <Header />
    <Body />
    <Footer />
</div>

//Application component
const App = () => <Page />

ReactDOM.render(<App />, document.getElementById('root'))

..............................................................................................
				React Dev tools
..............................................................................................

React dev tool is used to visualize the component tree in the browser, without looking the source code ,how the tree has been constructured.

How to install react dev tool?

https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?hl=en

How to use react dev tool?

 1.lanuch application
 2.open dev tool inside chrome
.............................................................................................
.............................................................................................
				Component Compostion and Modularity
..............................................................................................

In react application, we dont / never dump the code into single file, we need to modularize the application.

File Structure
Is there a recommended way to structure React projects?

  React doesn’t have any opinions on how you put files into folders. 
  That said there are a few common approaches popular in the ecosystem you may want to consider.

Grouping by "features" or "routes-menu"
  One common way to structure projects is to locate CSS, JS, and tests together inside folders grouped by feature or route.
			
common or util /
  Avatar.js
  Avatar.css
  APIUtils.js
  APIUtils.test.js
feed/
  index.js
  Feed.js
  Feed.css
  FeedStory.js
  FeedStory.test.js
  FeedAPI.js
profile/
  index.js
  Profile.js
  ProfileHeader.js
  ProfileHeader.css
  ProfileAPI.js

Grouping by file type
 Another popular way to structure projects is to group similar files together, for example:

api/
  APIUtils.js
  APIUtils.test.js
  ProfileAPI.js
  UserAPI.js
components/
  Avatar.js
  Avatar.css
  Feed.js
  Feed.css
  FeedStory.js
  FeedStory.test.js
  Profile.js
  ProfileHeader.js
  ProfileHeader.css

Some people also prefer to go further, and separate components into different folders depending on their role in the application. For example, Atomic Design is a design methodology built on this principle. Remember that it’s often more productive to treat such methodologies as helpful examples rather than strict rules to follow.

               "https://bradfrost.com/blog/post/atomic-web-design/"


File Name conventions:

 FileName must match component feature  - profile 

File Name can be saved as fileName.js or fileName.jsx

Rules for jsx extensions:

-Root file (index,App) files must not be saved with ".jsx" , root files must be saved only with .js extension.

-Barrel export feature must be used in large application.


src/links/link.jsx
import React from 'react'

const Link = () => <ul>
    <li><a href="letscreate">Let's Create</a></li>
    <li><a href="products">Products and Solutions</a></li>
    <li><a href="consulting">Consulting & Services</a></li>
    <li><a href="support">Learn & Support</a></li>
</ul>
export { Link };

src/menus/menubar.jsx
import React from 'react'
import { Link } from '../links/link'

const MenuBar = () => <nav>
    <Link />
</nav>

export { MenuBar }

src/header/header.jsx
import React from 'react'
import { MenuBar } from '../menus/menubar'

const Header = () => <header>
    <h1>IBM -header</h1>
    <hr />
    <MenuBar />
</header>

export {Header}


src/footer/footer.jsx
import React from 'react'

//Footer 
export const Footer = () => <header>
    <h1>IBM-Footer</h1>
</header>
//Page


src/body/body.jsx
import React  from "react"

export const Body = () => <div>
<p>
    International Business Machines Corporation (IBM) is an American multinational technology corporation headquartered in Armonk, New York, with operations in over 171 countries. The company began in 1911, founded in Endicott, New York, by trust businessman Charles Ranlett Flint, as the Computing-Tabulating-Recording Company (CTR) and was renamed "International Business Machines" in 1924. IBM is incorporated in New York
</p>
</div>

src/page/page.jsx
import { Header } from '../header/header'
import { Body } from '../body/body'
import { Footer } from '../footer/footer'

//component linking
export const Page = () => <div>
    <Header />
    <Body />
    <Footer />
</div>

src/App.js
import React from 'react'
import { Page } from './page/page'

const App = () => <Page />

export default App;


src/index.js
import ReactDOM from 'react-dom';
import App from './App';


ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................

.............................................................................................
				Barrel export
.............................................................................................

Use Case :

=>How to avoid multiple import of things from same folder
=>how to avoid file names while import

Barrel export solves the above problem

src/header
 -header.jsx
 -menubar.jsx
 -index.js

Steps:
1 inside every subfolders(header,body,profile)
 create index.js

2.import what ever you want to export outside 

3. you re export again what ever you have imported


src/header/index.js

import { Header } from './header'
import { MenuBar } from './menubar'

//barrel export : Re export
export { Header, MenuBar }
.............................................................................................
..............................................................................................
				How to Style components
..............................................................................................

CSS integration:
................

How to add css to an html element?

=> using class attribute  - external style
=> using style attribute - inline

HTML :
<div class="container">

</div>

<div style="background-color:red">

</div>

HTML ATTRIBUTES And JSX:

 We cant /should not add html attributes directly in jsx code.
 JSX uses certain rules for adding html attributes.

 "Since JSX is closer to JavaScript than to HTML, React DOM uses "camelCase property naming convention" instead of HTML attribute names"

For example, class becomes className in JSX, and tabindex becomes tabIndex.

<div className="container" tabIndex>

</div>

List of jsx attributes:
accept acceptCharset accessKey action allowFullScreen alt async autoComplete
autoFocus autoPlay capture cellPadding cellSpacing challenge charSet checked
cite classID className colSpan cols content contentEditable contextMenu controls
controlsList coords crossOrigin data dateTime default defer dir disabled
download draggable encType form formAction formEncType formMethod formNoValidate
formTarget frameBorder headers height hidden high href hrefLang htmlFor
httpEquiv icon id inputMode integrity is keyParams keyType kind label lang list
loop low manifest marginHeight marginWidth max maxLength media mediaGroup method
min minLength multiple muted name noValidate nonce open optimum pattern
placeholder poster preload profile radioGroup readOnly rel required reversed
role rowSpan rows sandbox scope scoped scrolling seamless selected shape size
sizes span spellCheck src srcDoc srcLang srcSet start step style summary
tabIndex target title type useMap value width wmode wrap

"https://reactjs.org/docs/dom-elements.html"

adding Events Handlers

 <button onClick={method}></button>
  
CSS : 

->You can add your own css - custom css
->you can add third party css frameworks -  bootstrap,materialdesign,spark...

import statement can be used to import js files.

import statement can also be used to import
=>css files
=>images
=>any static assets.


import React from 'react';
import ReactDOM from 'react-dom';
import { Page } from './layout/page';
import './index.css' //webpack automatically include this inside bundle
import './App.css'

const App = () => <div className="App">
    <Page />
</div>

ReactDOM.render(<App />, document.getElementById('root'))

Note: if you import css in root file(index.js), those css styles will be available across the applications.
..............................................................................................
				Component level css
.............................................................................................
if you want to apply/use css for a particular component.

src/header/header.css
.background {
    background-color: antiquewhite;
}

src/header/header.jsx
import React from 'react';
import './header.css'

export const Header = () => <header className="background">
    <h1>Sapient</h1>
</header>
.............................................................................................
			  How to add third party css - bootstrap
............................................................................................

Steps:

1.install bootstrap

npm install bootstrap --save

2.import bootstrap in index.js
import 'bootstrap/dist/css/bootstrap.css'

import React from 'react';
import ReactDOM from 'react-dom';
import { Page } from './layout/page';
// import './index.css' //webpack automatically include this inside bundle
// import './App.css'
import 'bootstrap/dist/css/bootstrap.css'

const App = () => <div className="container">
    <Page />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				Style Attribute
..............................................................................................


In html style is just a string

<div style="background-color:red">

In jsx(react) style is object

Style Object is nothing "css property representation in javascript"

CSS styles:

.className {
  background-color:pink;  //dash case notation
}

Css styles in javascript
 In js css styles are represented as camel case notation.

backgroundColor=pink

element.style.backgroundColor=pink

  "https://www.w3schools.com/jsref/dom_obj_style.asp"



Steps to create style object and attach with element

1.declare style object
//style object
const headerStyle = {
    backgroundColor: 'red'
};
2.attach with element
export const Header = () => <header className="background">
    <h1 style={headerStyle}>Sapient</h1>
</header>


import React from 'react';
import './header.css'

//style object
const headerStyle = {
    color: 'red'
};

export const Header = () => <header className="background">
    <h1 style={headerStyle}>Sapient</h1>
    <h2 style={{ color: 'blue' }}>Publisis</h2>
</header>
..............................................................................................
..............................................................................................
				  Dynamic Page - Data Binding
..............................................................................................

Types of web

1.static web
   -only html markup,hand coded.
2.dynamic web
   - html is created on fly with data

How to add data in the component /how to bind data in the component?

data can be represented in many ways.

-primitives - numbers,strings,boolean
-objects - literal objects, objects created out of class/function
-arrays - it is also object but collection 

How to bind data inside jsx?

let name='subramanian'

<h1>Hello {name} </h1>

{} -  databinding syntax.

data binding can be
{variable}
{expression} - {10*10} {getValue()} {emp.id}



import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'

//data binding : string,numbers,boolean,object , array

const firstName = 'Subramaian';
const score = 100;
const isvalid = true;
const address = {
    city: 'Coimbatore',
    state: 'Tamil Nadu'
}
//array
const skills = ['React', 'MicroServices', 'Java', 'Quarkus', 'Vertx'];

const Profile = () => <div>
    <h2>Name :  {firstName}</h2>
    <h2>Score :  {score}</h2>
    <h2>Status :  {isvalid ? "Valid" : "NotValid"}</h2>
    <h2>Address :  {address.city} , {address.state}</h2>
    <h2>Skills</h2>
    <ul>
        {
            skills.map(skill => {
                return <li> {skill}</li>
            })
        }
    </ul>

</div>
const App = () => <div>
    <Profile />
</div>

ReactDOM.render(<App />, document.getElementById('root'))


..............................................................................................
			  Compoent Design Principles of React
.............................................................................................


Data can be declared for a component in two ways.

1.data is supplied from outside the component.
2.data is supplied within the component


1.Data is supplied from outside the component.

When component receives data from the outside, this pattern is called as "property pattern" / props pattern.

Outside the component means what? What is outside for the component?

YOu know very well , react creates components and assembles them in hierachical order(tree)
in the tree model, the one component called as "parent" component and other components are called child component and sibiling components.

outside means "Parent".

    "Data is supplied from the parent compoent to child component" - Props pattern /Property pattern
..............................................................................................

import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'

//how to supply data to Greeter from outside-(App)
//name =  {name:'Subramanian' ,city:'Coimbatore}
// function Greeter(props) {
//     return <h1>Hello {props.name} {props.city} times {props.times}</h1>
// }

const Greeter = props => <h1>Hello {props.name} {props.city} times {props.times}</h1>

/**
 * 
 * @returns 
 *  {
 *    name:'subramanian'
 *  }
 */
const App = () => <div>
    {/* {Greeter('Subramanian')} */}
    {/** data is supplied as object only - props */}
    <Greeter name="Subramanian" city="Coimbatore" times={1} />
    <Greeter name="Ram" city="Delhi" times={100} />

</div>

ReactDOM.render(<App />, document.getElementById('root'))
Note: 
 property vs html attributes

<h1 style="background-color:red">
     |
    attribute
<Profile name="Ram" />
          |
      props/property

props and attribtues are syntax based same.

but they are different.

props are special attributes supplied to the components
attributes are supplied to the html elements.


import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'

export const Name = props => <div>
    <h3>Name {props.firstName} {props.middleName} {props.lastname}</h3>
</div>
export const Address = props => <div>
    <h3>Address {props.city} {props.state} {props.country}</h3>
</div>

//Profile: 
export const Profile = props => <div>
    <h1>Id  : {props.id}</h1>
    <Name firstName={props.firstName} middleName={props.middleName} lastname={props.lastname} />
    <Address city={props.city} state={props.state} country={props.country}/>
</div>


const App = () => <div>
    <Profile id={1} firstName="Subramanian" middleName="" lastname="Murugan" city="Coimbatore" />
</div>

ReactDOM.render(<App />, document.getElementById('root'))



class Profile extends React.Component {
    
    render(){
        return <div className="container">
                <h1>Profile details</h1>
        </div>
    }
}

In the class components  how to access props?

 React.Component base class has instance variable "props" , this variables gets initalized when ever we pass props


=>In side Component class , props instance variable by default gets initalized with empty literal object

   class Compoent{
     props = {};
   }
=> As soon as we pass properties , props instance variable's object gets augmented(added)

function props vs class props

=>function props are passed as parameter
=>class props are initalized with help of instance variable
import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'


//class Component and Props
class Greeter extends React.Component {
  
    //override
    render(){
        console.log(this.props)
        return <div>
            <h1>{this.props.message} {this.props.name}</h1>
        </div>
    }

}

const App = () => <div>
     <Greeter name="Subramaian" message="Hai" />
</div>

ReactDOM.render(<App />, document.getElementById('root'))

..............................................................................................
			What if i dont supply Props to Component -Default Props
.............................................................................................
if you dont pass any property, we can supply default props which saves lot of runtime bugs.

When you design component, it is highly recommended to have default Props- This is best Practice
import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'

//default Args
function multiply(a = 0, b = 0) {
    console.log(`a ${a} b ${b}`)
    return a * b; //NaN
}
console.log(multiply(6, 3))
console.log(multiply())

const Profile = props => {
    return <div className="container">
        <h1>Profile details</h1>
        <h2>Id : {props.id}</h2>
        <h2>Name {props.name.toUpperCase()}</h2>
        <h2>Status {props.status ? "Avaiable" : "Not Available"}</h2>
    </div>
}
//default Props
Profile.defaultProps = {
    id:0,
    name:'default',
    status:false
}

const App = () => {
    return <div>
        <Profile />
        <Profile id={100} />
        <Profile id={100} name="Ram" />

    </div>
}
ReactDOM.render(<App />, document.getElementById('root'))

..............................................................................................
			Property Validation or Property Constraints
.............................................................................................

Javascript is dynamic typed language, meaning that the type of variable is not verified during compile time.

dyamic typed/weak typing

var a=1;
console.log(a) => 1 => type is number

you can reinitalize the with different types
a="hello"
console.log(a) => "hello" => type is string

In c: - Strongly typed  /static typed
int a=10
a="hello" -compile time error 

Type script : Strongly static typed javascript

let a:number =10;
a="hello"


Inside compoent if pass data , can i enforce the react that accept only the type what i want.

Yes , we can do with help of property validator.
Property validator gives only warning , it wont stop rendering incase there is any type error.


in order to write property rule, react provides a separate lib "prop-types"


import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'
import PropTypes from 'prop-types'

const Profile = props => {
    return <div className="container">
        <h1>Profile details</h1>
        <h2>Id : {props.id}</h2>
        <h2>Name {props.name.toUpperCase()}</h2>
        <h2>Status {props.status ? "Avaiable" : "Not Available"}</h2>
    </div>
}
//if you dont pass any property, we can supply default props which saves lot of runtime bugs.
Profile.defaultProps = {
    id: 0,
    name: 'default',
    status: false
}
//property validation
//set property validation rules for property
Profile.propTypes = {
    //rules for property
    id: PropTypes.number,
    name: PropTypes.string,
    status: PropTypes.bool
}

const App = () => {
    return <div>
        {/* <Profile id={"ddd"} name="ram" status={"test"} /> */}

        <Profile id={33} name="ram" status={true} />

    </div>
}
ReactDOM.render(<App />, document.getElementById('root'))

				Property validation in class Components
import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'
import PropTypes from 'prop-types';

class Profile extends React.Component {
    //default props inside class : which is not recommended
    static defaultProps = {
        id: 0,
        name: 'default',
        status: false
    }
    static propTypes = {
        //rules for property
        id: PropTypes.number,
        name:PropTypes.string,
        status:PropTypes.bool
    }
    
    render() {
        console.log(this.props)
        return <div className="container">
            <h1>Profile details</h1>
            <h2>Id : {this.props.id}</h2>
            <h2>Name {this.props.name}</h2>
            <h2>Status {this.props.status ? "Avaiable" : "Not Available"}</h2>
        </div>
    }
}
// Profile.defaultProps = {
//     id: 0,
//     name: 'default',
//     status: false
// }
//set property validation rules for property
// Profile.propTypes = {
//     //rules for property
//     id: PropTypes.number,
//     name:PropTypes.string,
//     status:PropTypes.bool
// }

const App = () => {
    return <div>
         <Profile id={1} name="ram" status={true} />

    </div>
}
ReactDOM.render(<App />, document.getElementById('root'))

https://www.npmjs.com/package/protypes
.............................................................................................
				React Design Patterns and Principles


Compoent Design Principles:

	Component is designed based on "functional programming principles".
 React lib has been designed based on functional programming principles.


Functional Programming principles:

1.pure functions

 in order to certifiy the function is pure , there are two rules.

A.function receives the set of args, which should return the same.


//pure function.

//pure function or not
function getMessage(message) {
    return message;
}
console.log(getMessage('hello'))

//impure function
function calculate(a) {
    let b = 100;
    // let res = a * 10
    // return res;
    return a * b;
}


function should not do any "side effects"(changing the input parameters, local variable,IO operation), if fun does, that function is called "impure function".


In React where pure function is used.
 
  In the component design.

        "Every Component is pure function with respect to props"

 Every component receives props as parameter , returns the same without mutation(side effects).

import React from "react";
import ReactDOM from "react-dom";
import 'bootstrap/dist/css/bootstrap.css'

//This function is pure function : function gets props as input and return as it is without muation.
const Greeter = props => {
    return <div>
        <h1>Hello {props.name}</h1>
    </div>
}

const App = () => <div>
    <Greeter name="Subramnaian" />
</div>
ReactDOM.render(<App />, document.getElementById('root'))

		    "Props are readonly"  -props should not/cant be changed


B. to be discussed later.
..............................................................................................
..............................................................................................
				Property Rethrow
..............................................................................................

If a component receives property, the same set of property to be passed down to its childern.

import React from 'react';
import ReactDOM from 'react-dom'


// const ProfileMaster = props => {
//     return <ProfileDetails
//         id={props.id}
//         name={props.name}
//         status={props.status}
//         city={props.city} />
// }
//spread operator -  ...
const ProfileMaster = props => {
    return <ProfileDetails {...props} title="Profile Details" />
}

const ProfileDetails = props => {

    return <div>
        <h1>{props.title}</h1>
        <h1>id {props.id}</h1>
        <h1>Name {props.name}</h1>
        <h1>City {props.city}</h1>
        <h1>Status {props.status ? "available" : "Not Available"}</h1>
    </div>

}

const App = props => {
    return <div>
        <ProfileMaster id={1} name="subramanian" status={true} city="coimbatore" />
    </div>
}
ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				Object Destructuring and React
.............................................................................................

//Object destructuring

// function showEmployee(employee) {
//     console.log(`Id ${employee.id}`)
//     console.log(`Name ${employee.name}`)
//     console.log(`city ${employee.address.city}`)
// }

// function showEmployee(employee) {
//     const { id, name, address: { city } } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`city ${city}`)
// }

// const showEmployee = (employee) => {
//     const { id, name, address: { city } } = employee;
//     console.log(`Id ${id}`)
//     console.log(`Name ${name}`)
//     console.log(`city ${city}`)
// }
const showEmployee = ({ id, name, address: { city } }) => {
    console.log(`Id ${id}`)
    console.log(`Name ${name}`)
    console.log(`city ${city}`)
}
showEmployee({ id: 1, name: 'Ram', address: { city: 'coimbatore' } })
/////////////////////////////////////////////////////////////////////////////////////

//returning object
// function getStockValues() {
//     return {
//         id: 1,
//         symbol: 'google',
//         qty: 100,
//         price: 10000
//     }
// }
// console.log(getStockValues())

//how to populate object 
// function getStockValues(id = 1, symbol = 'google', qty = 0, price = 0) {
//     return {
//         id: id,
//         symbol: symbol,
//         qty: qty,
//         price: price
//     }
// }

// function getStockValues(id = 1, symbol = 'google', qty = 0, price = 0) {
//     //if objectVariable:localcalVariable is same 
//     // leftside:rightside is same 
//     //make it one.
//     return {
//         id,
//         symbol,
//         qty,
//         price
//     }
// }
// const getStockValues = (id = 1, symbol = 'google', qty = 0, price = 0) => {
//     return {
//         id,
//         symbol,
//         qty,
//         price
//     }
// }
const getStockValues = (id = 1, symbol = 'google', qty = 0, price = 0) => ({
    id,
    symbol,
    qty,
    price
})

console.log(getStockValues())
console.log(getStockValues(100, 'Facebook', 100, 1988))

..............................................................................................
					React and Destructuring
import React from 'react';
import ReactDOM from 'react-dom'


const ProfileMaster = props => {
    return <ProfileDetails {...props} title="Profile Details" />
}
//without destrucing
// const ProfileDetails = props => {
//     return <div>
//         <h1>{props.title}</h1>
//         <h1>id {props.id}</h1>
//         <h1>Name {props.name}</h1>
//         <h1>City {props.city}</h1>
//         <h1>Status {props.status ? "available" : "Not Available"}</h1>
//     </div>
// }
//destrucing inside function
// const ProfileDetails = props => {
//     const { title, id, name, city, status } = props;
//     return <div>
//         <h1>{title}</h1>
//         <h1>id {id}</h1>
//         <h1>Name {name}</h1>
//         <h1>City {city}</h1>
//         <h1>Status {status ? "available" : "Not Available"}</h1>
//     </div>
// }

// //argument destrucing
const ProfileDetails = ({ title, id, name, city, status }) => <div>
    <h1>{title}</h1>
    <h1>id {id}</h1>
    <h1>Name {name}</h1>
    <h1>City {city}</h1>
    <h1>Status {status ? "available" : "Not Available"}</h1>
</div>

const App = props => {
    return <div>
        <ProfileMaster id={1} name="subramanian" status={true} city="coimbatore" />
    </div>
}


ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
..............................................................................................
				What  can be a prop
.............................................................................................

Prop can be 

1.data - numbers,strings,boolean,objects,arrays
2.function - function as prop
3.component /any html element can be prop

Prop can be 

1.static prop - discussed already
2.dynamic prop 
.............................................................................................

Component as Prop
.................

<Container/>  - The component has no child

<Container>  - The component has child
   <Header>    - It is passed as child to Container
</Container>

import React from 'react';
import ReactDOM from 'react-dom'

const Header = props => <div>
    <h1>{props.title}</h1>
    {props.children}
</div>

const MenuBar = props => <ul>
    {props.items.map(menu => <li>
        <a href={`${menu}`}>{menu}</a>
    </li>)}
</ul>

const Page = props => <div>
    {props.children}
</div>


const Wrapper = props => <div>
    {props.children}
</div>

const App = () => {
    return <Wrapper>
        <Page>
            <Header title="Rakuten">
                <MenuBar items={["home", "services", "contactus"]} />
                <hr/>
            </Header>
        </Page>
    </Wrapper>
}
ReactDOM.render(<App />, document.getElementById('root'))
............................................................................................
..............................................................................................
				Lists(Arrays) and Keys
..............................................................................................

How to render list of components / data?

Javascript provides an array to store data.

Array of primitives
Array of objects

Lists and UI design:
...................

List can be used to design different types of  ui.

1.ListView -  ul ...li
2.cardView  - div...div
3.gridView - table ..tr

import React from 'react';
import ReactDOM from 'react-dom'
import { TODOS } from './mock-data/todos';

const NumberList = props => <div>
    {
        props.scores.map(score => {
            return <li key={score}>{score}</li>
        })
    }
</div>
// const TodoList = props => <div>
//     {
//         props.todos.map(todo => {
//             return <div key={todo.id}>
//                 <p>id {todo.id}</p>
//                 <p>title {todo.title}</p>
//                 <p>Status {todo.completed ? "done" : "not Completed"}</p>
//             </div>
//         })
//     }
// </div>

const TodoList = props => <div>
    {
        props.todos.map(todo => {
            return <TodoItem todo={todo} />
        })
    }
</div>
const TodoItem = ({ todo }) => <div key={todo.id}>
    <p>id {todo.id}</p>
    <p>title {todo.title}</p>
    <p>Status {todo.completed ? "done" : "not Completed"}</p>
</div>


const scores = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
const App = props => <div>
    <NumberList scores={scores} />
    <TodoList todos={TODOS} />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
.............................................................................................
					Fragments
............................................................................................

React Basic Jsx Rules:

1.We must have root element.
  
invalid code
<p>Hello</p>
<h1>Hai</h1>

JSX Rule:

1.YOu must wrapp sibblings inside container elements

Valid
 <div>
   <h1>
   <p>
   <img>
   <Trader/>
 </div>

Invalid:
   <h1>
   <p>
   <img>
   <Trader/>
............
What is Fragment?

A  common pattern in React is for a component return multiple elements.


function Greeter (){
   return <h1></h1><p></p>
}

Here , the code throws error , the reason being , we cant have elements without root element.

This rule some times, makes ui layout complex. sometime which may make difficult to adjust the ui layouts.


// import React, { Fragment} from 'react';
import React from 'react';

import ReactDOM from 'react-dom'

// const Greeter = () => <React.Fragment>
//     <h1>Hello</h1>
//     <p>How are you?</p>
// </React.Fragment>

// const Greeter = () => <Fragment>
//     <h1>Hello</h1>
//     <p>How are you?</p>
// </Fragment>

const Greeter = () => <>
    <h1>Hello</h1>
    <p>How are you?</p>
</>

const App = props => <div>
    <Greeter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))




// import React, { Fragment} from 'react';
import React from 'react';

import ReactDOM from 'react-dom'

// const Greeter = () => <React.Fragment>
//     <h1>Hello</h1>
//     <p>How are you?</p>
// </React.Fragment>

// const Greeter = () => <Fragment>
//     <h1>Hello</h1>
//     <p>How are you?</p>
// </Fragment>

const Greeter = () => <>
    <h1>Hello</h1>
    <p>How are you?</p>
</>
//Table  - Grid

const Grid = props => {
    return <table border="1">
        <thead >
            <Columns />
        </thead>
        <GridBody users={props.datasource} />
    </table>
}
// //withoutFragement
// const Columns = props => {
//     return <div>
//         <td>Name</td>
//         <td>Location</td>
//     </div>
// }

//withFragement
const Columns = props => {
    return <>
        <td>Name</td>
        <td>Location</td>
        <td>Email</td>

    </>
}
const GridBody = props => {
    return <>
        <tbody>
            {
                props.users.map((user, index) => {
                    return <tr key={index}>
                        <th scope="row">{user.id}</th>
                        <td>{user.name}</td>
                        <td>{user.email}</td>
                    </tr>
                })
            }

        </tbody>
    </>
}

const USERS = [
    { id: 1, name: 'subramaian', email: 'subu@gmail.com' },
    { id: 2, name: 'Dodge', email: 'dodge@gmail.com' }
]
const App = props => <div>
    <Greeter />
    <Grid datasource={USERS} />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				Component Communication - Patterns
.............................................................................................

1.Parent to Child 
   Components can share data from the parent to child via props
2.Across the components - Global Data
   1.Share data across the components via "Redux".
   2.React Context  Object used to share global data inside react itself
3.Child to Parent
   Generally , we cant share child to parent, only possibly via lib called "Redux"
..............................................................................................
				React Context  - To share data 
..............................................................................................

What is Context?
 
Object helps to transfer data from parent to anywhere in herierchy.

Context provides a way to pass data through the component tree without having to pass props down manually at every level.

When to use context?

Context is designed to share data that can considered "global" for a tree of React components
such as "theme , login data, preferred langugage".

You should not share biz data via context.

Without Context?
import React from 'react';
import ReactDOM from 'react-dom'


const ThemedButton = props => <div>
    <Button theme={props.theme} />
</div>
const Button = props => <div>
    <button style={{ color: 'whitesmoke', backgroundColor: props.theme }}>Hello!</button>
</div>
const Toolbar = props => <div>
    <ThemedButton theme={props.theme} />
</div>
const Page = props => <>
    <Toolbar theme={props.theme} />
</>

const theme = {
    dark: "black"
}
const App = () => <div>
    <Page theme={theme.dark} />
</div>


ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
					React.createContext

Returns two objects

1.Provider
   Where we share data
2.Consumer
   Where we consume data


import React, { createContext } from 'react';
import ReactDOM from 'react-dom'


//create Context object 
// const themeContext = React.createContext('theme')
// const themeContext = createContext('theme')
const { Provider, Consumer } = createContext('theme')


const ThemedButton = props => <div>
    <Button />
</div>
const Button = props => <div>
    {/* Consumer */}
    <Consumer>
        {theme => {
            //return jsx 
            return <button style={{ color: 'whitesmoke', backgroundColor: theme.dark }}>Hello!</button>
        }
        }
    </Consumer>

</div>
const Toolbar = props => <div>
    <ThemedButton />
</div>
const Page = props => <>
    <Toolbar />
</>

const theme = {
    dark: "green"
}
const App = () => <div>
    <Provider value={theme}>
        <Page />
      
    </Provider>
</div>


ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				Conditional Rendering

 you can create distinct components that encapsulate behavior you need. Then, you can render only some of them, depending on the state of your application.

Conditional rendering in React works the same way conditions work in JavaScript. Use JavaScript operators like if or the conditional operator to create elements representing the current state, and let React update the UI to match them.

import React from 'react';
import ReactDOM from 'react-dom'



const DashBoard = props => <div>
    <h1>DashBoard</h1>
</div>
const SignUp = props => <div>
    <h1>Please SignUp!</h1>
</div>

// const Login = props => {
//     const { username, password } = props.user;
//     if (username === 'admin' && password === 'admin') {
//         return <DashBoard />
//     }
//     return <SignUp />

// }

// const Login = props => {
//     const { username, password } = props.user;
//     const status = (username === 'admin') && (password === 'admin');
//     return status ? <DashBoard /> : <SignUp />
// }

// const Login = props => {
//     const { username, password } = props.user;
//     return (username === 'admin') && (password === 'admin') ? <DashBoard /> : <SignUp />
// }
const Login = ({ user: { username, password } }) => (username === 'admin') && (password === 'admin') ? <DashBoard /> : <SignUp />


const App = () => <div>
    <Login user={{ username: 'admin', password: 'admin' }} />
    <Login user={{ username: 'foo', password: 'bar' }} />

</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				   What can be return value?
import React from 'react';
import ReactDOM from 'react-dom'

//Return value can be jsx element

// const MyComponent = ()=> {
//     return <h1>JSX Element</h1>
// }
//return value can be primitives values
// const MyComponent = ()=> {
//     return "Hello"
// }
// const MyComponent = ()=> {
//     return 10
// }

// const MyComponent = ()=> {
//     return true
// }
// const MyComponent = ()=> {
//     return true
// }
// const MyComponent = ()=> {
//     return [1,2,3,4,5,5]
// }
//objects cant be returned
// const MyComponent = () => {
//     return { name: 'test' }
// }
//valid; but no output
// const MyComponent = () => {
//     return  //undefined
// }
//valid but no output
const MyComponent = () => {
    return null //undefined
}
const App = () => <div>
    <MyComponent />
</div>

ReactDOM.render(<App />, document.getElementById('root'))



..............................................................................................
				     State
.............................................................................................

..............................................................................................
				  Dynamic Data- How to Mutate data
..............................................................................................

How to mutate data inside component?

With Respect to props, data cant be changed by the component.

What if i want to change the data?
  There is pattern called state pattern.

In Old React, state pattern can be introduced only inside "class Component".

The word state means data of component.

React.Component class has instance variable called "state"

state
 The state contains data specific to this component that may change over time.
 The state is user-defined, and it should be a plain JavaScript object.

state variable's default value is "null".
we are expected to initalize the data of the component inside object and assign that object to state variable.

state = {


}
Features of state:

1.state is always "object" - we need to encapsulate the data inside literal object like props.

Steps: 
1.declare component class and initalize the state variable,bind in the UI

import React from 'react';
import ReactDOM from 'react-dom'

//state 
class Counter extends React.Component {
    //initalize the state 
    state = {
        //here your component specific data
       counter:0  //initalize state //
    };

    render() {
        console.log(this.state)
        return <>
            <h1>Counter Application</h1>
            <h3>Counter : {this.state.counter}</h3>
        </>
    }

}

const App = () => <div>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))

..............................................................................................
				User Interaction and Components
.............................................................................................

Any UI is subject to user interaction.

How to interact with User interface?
 "Event Handling"

Handling Events:
..................

Handling events with React elements is very similar to handling events on DOM elements.

There are some syntax differences:

React events are named using camelCase, rather than lowercase.
With JSX you pass a function as the event handler, rather than a string.

HTML:
<button onclick="activateLasers()">
  Activate Lasers
</button>
JSX:
<button onClick={method}>
  Activate Lasers
</button>

Step 2: Declare Event Listener , bind Event Listener with button

import React from 'react';
import ReactDOM from 'react-dom'

//state 
class Counter extends React.Component {
    //initalize the state 
    state = {
        //here your component specific data
        counter: 0  //initalize state //
    };

    //event listner
    onIncrement = () => {
        alert('button')
    }

    render() {
        console.log(this.state)
        return <>
            <h1>Counter Application</h1>
            <h3>Counter : {this.state.counter}</h3>
            <button onClick={this.onIncrement}>+</button>
        </>
    }

}

const App = () => <div>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))



How React updates UI?

via "render method"

render:
 
=>it is method called by react engine.
     can we call render directly inside event listener?
        Yes,but no impact on ui update 
    onIncrement = () => {
         //increment value of state 
        this.state.value = this.state.value + 1
        console.log("value : ",this.state.value)
        this.render()
    }
   Note : render should not be called directly

How to call render?
render is called by react engine only.
how react engine will triger render?
  via React api "setState() ,forceUpdate()"


Syntax:

setState(updater, [callback])

updater = it is function
callback =it is also function which optional parameter

updater:
 function having state mutation logic

step1:
    this.setState(function(){
            console.log('state mutation logic goes')
        })

updater function syntax:

takes two args

1.state  is just variable you can have any name - holds the value of state object
 which is called as "previous state" or "old state"
2.props is just variable holding current props variable- which is optional

function(state,[props]){
            console.log('state mutation logic goes')
}

function(prevState){
            console.log('state mutation logic goes')
}

Updater function returns object, what object, if you want to understand this , we need to under one more functional programming principle called "Pure function 2nd Rule".

Updater function returns object, what object, if you want to understand this , we need to under one more functional programming principle called "Pure function 2nd Rule".


Pure Functions:

Rule A:
  If function receives input, the function returns the same input without any mutation.
  Every Component with respect to props, are pure functions.

Rule B:

 What if function receives input, need to be mutated but it should follow the pure function rule.

With help of "Immutablity"

What is immutable?

creating new object every time when you update the object , immutablity.

if the function does that , that function is called pure function.

pure function must return, "immutable object".

//Pure functions :2nd rule

//Impure function : it changes the input parameter
function updateProfile_(profile, city) {
    //update city and return updated profile object: 
    profile.city = city
    return profile;
}
//Pure function : i need to change the input parameter but it should be pure.
function updateProfile(profile, city) {
    //update city and return updated profile object: 
    //return new Object ,by copying all properties ,with updated

    //in order to return new Object we have many synatx
    //old syntax : we copy object properties manually 
    // return {
    //     id: profile.id,
    //     name: profile.name,
    //     city: city
    // }
    //2nd syntax:
    // return Object.assign({}, profile, { city: city })
    //3rd syntax: spread notation
    return { ...profile, city }
}

let profile = {
    id: 1,
    name: 'Subramanian',
    city: 'Chennai'
}
// console.log('Before Update', profile)
// console.log('After Update', updateProfile(profile, 'Coimbatore'))
let updatedProfile = updateProfile(profile, 'Coimbatore')
console.log(profile === updatedProfile ? "Same Object " : " Different Object")

What you can make immutable?

->literal objects
->Array objects

//Pure functions :2nd rule

//Impure function : it changes the input parameter
function updateProfile_(profile, city) {
    //update city and return updated profile object: 
    profile.city = city
    return profile;
}
//Pure function : i need to change the input parameter but it should be pure.
function updateProfile(profile, city) {
    //update city and return updated profile object: 
    //return new Object ,by copying all properties ,with updated

    //in order to return new Object we have many synatx
    //old syntax : we copy object properties manually 
    // return {
    //     id: profile.id,
    //     name: profile.name,
    //     city: city
    // }
    //2nd syntax:
    // return Object.assign({}, profile, { city: city })
    //3rd syntax: spread notation
    return { ...profile, city }
}

let profile = {
    id: 1,
    name: 'Subramanian',
    city: 'Chennai'
}
// console.log('Before Update', profile)
// console.log('After Update', updateProfile(profile, 'Coimbatore'))
let updatedProfile = updateProfile(profile, 'Coimbatore')
console.log(profile === updatedProfile ? "Same Object " : " Different Object")

//arrays and immutatblity
//impure
// function addTodo(todos, newTodo) {
//     return todos.push(newTodo)
// }
//pure : how to return array immutable
function addTodo(todos, newTodo) {
    //return todos.concat(newTodo)
    return [...todos,newTodo]
}
let todos = [{
    title: 'Learn react',
    done: true
}];

Object.freeze(todos)
console.log(addTodo(todos, { title: 'Learn Pure functions', done: false }))

List of Array immutable apis:

1.concat
2.map
3.filter
3.reduce

updaterFunction Return value:

=>Should return always immutable object.

                    "setState method is pure function"


import React from 'react';
import ReactDOM from 'react-dom'

//state 
class Counter extends React.Component {
    //initalize the state 
    state = {
        //here your component specific data
        counter: 0  //initalize state //
    };

    //event listner
    onIncrement = () => {
        // this.state.counter = this.state.counter + 1
        // console.log("Inside Listener => ", this.state.counter);
        // //trigger setState method
        // this.setState(function (prvState) {
        //     console.log("old state => ", prvState)
        //     // return {
        //     //     counter: prvState.counter + 1
        //     // }
        //     // return Object.assign({}, prvState, { counter: prvState.counter + 1 })
        //     return { ...prvState, counter: prvState.counter + 1 }
        // })
        this.setState((prvState) => {
            console.log("old state => ", prvState)
            return { ...prvState, counter: prvState.counter + 1 }
        })
    }

    render() {
        console.log("Current State => ", this.state)
        return <>
            <h1>Counter Application</h1>
            <h3>Counter : {this.state.counter}</h3>
            <button onClick={this.onIncrement}>+</button>
        </>
    }

}

const App = () => <div>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				Event Binding Syntaxs:

import React from 'react';
import ReactDOM from 'react-dom'

//state 
class Counter extends React.Component {
    //initalize the state 
    state = {
        counter: 0
    };

    //event listner
    onIncrement = () => {
        this.setState((prvState) => {
            console.log("old state => ", prvState)
            return { ...prvState, counter: prvState.counter + 1 }
        })
    }

    render() {
        console.log("Current State => ", this.state)
        return <>
            <h1>Counter Application</h1>
            <h3>Counter : {this.state.counter}</h3>
            <button onClick={this.onIncrement}>+</button>
            <button onClick={() => {
                this.setState(prvState => ({ ...prvState, counter: prvState.counter - 1 }))
            }}>-</button>

        </>
    }

}

const App = () => <div>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
.............................................................................................
				Multi State
............................................................................................
import React from 'react';
import ReactDOM from 'react-dom'

//state 
class Counter extends React.Component {
    //initalize the state 
    state = {
        incValue: 10,
        decValue: 100
    };

    //event listner
    onIncrement = () => {
        this.setState((prvState) => {
            console.log("old state => ", prvState)
            return { ...prvState, incValue: prvState.incValue + 1 }
        })
    }

    render() {
        console.log("Current State => ", this.state)
        return <>
            <h1>Counter Application</h1>
            <h3>Increment Value : {this.state.incValue} - Decrement Value {this.state.decValue}</h3>
            <button onClick={this.onIncrement}>+</button>
            <button onClick={() => {
                this.setState(prvState => ({ ...prvState, decValue: prvState.decValue - 1 }))
            }}>-</button>

        </>
    }

}

const App = () => <div>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
.............................................................................................
				State As Prop  - dynamic Props

.............................................................................................
				Dyanmic Props - State as prop
..............................................................................................

The state of component can be passed as prop to another component.

Component Responsiblity:

1.A Component owns data(state) and biz logic(where state mutation happens).
   -StateFull Component
 Statefull Component is other wise called as "Container Component"

classes are used as container/statefull components

2.A Component owns only UI logic
   -Stateless component
 Stateless component is other wise called as "Presentational Component"

functions are used as "stateless component / presentational Component"

functional components receives data from class components.

state as prop:Dynamic Props
function as prop: how to pass listener function as prop.
import React from 'react';
import ReactDOM from 'react-dom'

//Container Component
class Counter extends React.Component {
    //initalize the state 
    state = {
        incValue: 10,
        decValue: 100
    };

    onIncrement = () => {
        this.setState((prvState) => {
            return { ...prvState, incValue: prvState.incValue + 1 }
        })
    }
    onDecrement = () => {
        this.setState(prvState => ({ ...prvState, decValue: prvState.decValue - 1 }))
    }
    render() {
        return <>
            {/* Here we pass state as prop,function as prop */}
            <CounterDisplay {...this.state}
                onIncrement={this.onIncrement}
                onDecrement={this.onDecrement} />
        </>
    }

}
//presentational Component
const CounterDisplay = props => <><h1>Counter Application</h1>
    <h3>Increment Value : {props.incValue} - Decrement Value {props.decValue}</h3>
    <button onClick={props.onIncrement}>+</button>
    <button onClick={props.onDecrement}>-</button>
</>

const App = () => <div>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
..............................................................................................					Event Listners Deep dive
..............................................................................................

SyntheticEvent:

 _ it is Event object provided by react to refer dom elements inside react components.

Event Object provides lot of apis

api:

boolean bubbles
boolean cancelable
DOMEventTarget currentTarget
boolean defaultPrevented
number eventPhase
boolean isTrusted
DOMEvent nativeEvent
void preventDefault()
boolean isDefaultPrevented()
void stopPropagation()
boolean isPropagationStopped()
void persist()
DOMEventTarget target
number timeStamp
string type

target : To refer the DOM object
..............................................................................................
		 How to get Input from the User -How to use Syn Event Object
...........................................................................................

SyntheticEvent object is passed as arg to event listner

 onIncrement = (evt) => {
        
 }

import React, { Component } from 'react';
import ReactDOM from 'react-dom'
import 'bootstrap/dist/css/bootstrap.css'


class UserInput extends Component {
    state = {
        text: 'default'
    }
    onUpdate = evt => {
        //read textbox value
      const value= evt.target.value
      this.setState(prevState=>({...prevState,text:value}))
    }

    render() {
        return <div className="container">
            <h1>User Input Application</h1>
            <h1> {this.state.text}</h1>
            <input onChange={this.onUpdate } />
        </div>
    }

}


const App = props => <div>
    <UserInput />
</div>
ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
				Component Life Cycles

Can be classified into 3 phases
1.Mount
2.Update
3.UnMount


1.Mounting
 This is inital phase of an component

 These methods are called in the following order when an instance of a component is being   created and inserted into the DOM:

1.constructor() -
2.static getDerivedStateFromProps()
3.render()
4.componentDidMount()

Mount phase methods are called only once, execpt one method - render.

import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'

class ParentComponent extends Component {
    state = {
        i: 0
    }
    //mount phase methods
    constructor() {
        super()
        console.log('Parent Constructor is called')
    }
    render() {
        console.log('Parent render is called')
        return <div>
            <h1>Parent Component</h1>
            <ChildComponent />
        </div>
    }

    componentDidMount() {
        console.log('Parent ComponentDidMount is called')
    }


}

class ChildComponent extends Component {

    state = {
        j: 0
    }
    //mount phase methods
    constructor() {
        super()
        console.log('ChildComponent Constructor is called')
    }
    render() {
        console.log('ChildComponent render is called')

        return <div>
            <h1>Child Component</h1>
        </div>
    }

    componentDidMount() {
        console.log('ChildComponent ComponentDidMount is called')
    }



}

ReactDOM.render(<ParentComponent />, document.getElementById('root'))


Parent Constructor is called
index.js:15 Parent render is called
index.js:37 ChildComponent Constructor is called
index.js:40 ChildComponent render is called
index.js:48 ChildComponent ComponentDidMount is called
index.js:23 Parent ComponentDidMount is called

Note:

constructors are not used now days-No focus on Constructor

static getDerivedStateFromProps() -  less use , no need to focus.

render()

 -It is called when component prepares object tree - vdom
 render -----cons---render---cons---render-Tree will be ready.

Once the tree is ready, which mounts/inserts the VDOM into Real DOM via ReactDOM.render()

ReactDOM.render() is entry and exit point of React Application,ReactDOM.render translates the Virtual DOM into real DOM.


ReactDOM.render(<Component1/>)--->Component1.constructor -Component1.render ----Component2.constructor----Component2.render----Component3.Constructor--Component3.render => Tree is Ready---->ReactDOM.render(V.Tree)---|Insert in real DOM.
..........................................................................................
componentDidMount :

componentDidMount is called after vdom inserted into real DOM.

ReactDOM.render(<Component1/>)--->Component1.constructor -Component1.render ----Component2.constructor----Component2.render----Component3.Constructor--Component3.render => Tree is Ready---->ReactDOM.render(V.Tree)---|Insert in real DOM ---|Component3.componentDidMount---->Component2.componentDidMount---Component1.componentDidMount

This is method is used heavily in the component life cycles.

Use cases:
1.For resource insentive works
->Ajax calls
->Web sockets
->Timers code
->Rxjs initalization

............................................................................................
			Web Service Integration in React -Ajax
............................................................................................

How to integrate ajax in react?

React has no any api for talking to webservice.
You can use any popular ajax libs.

1.fetch
2.axios
3.any ajax apis

fetch


import React, { Component } from 'react';
import ReactDOM from 'react-dom'
import 'bootstrap/dist/css/bootstrap.css'


class Todo extends Component {
    
    render() {
        return <div>
            <h1>TodoApp-WebService Integration</h1>
        </div>
    }
    componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        fetch(url).then(response => response.json()).then(todos => {
            console.log(todos)
        }).catch(err => {
            console.log(err)
        });
    }
}

const App = () => <div className="container">
    <Todo />
</div>

ReactDOM.render(<App />, document.getElementById('root'))

.............................................................................................
	   How to show data in the UI which was fetched from the WebServices
..............................................................................................

There are three possibilites you have when you do ajax calls

1.You may have data on time
2.You may not have data on time - delay or slow
    incase of slow data fetch we show "spinners"
3.you may get error
    server down,network failure,api malfunctions....

You have to write code according to state of api

 - success on time
 - success with spinner
 - error 

if you have to write if condition to check these three status, according to the status we switch mode.

How to write if ...else conditions in side jsx?
   Conditional Rendering


import React, { Component } from 'react';
import ReactDOM from 'react-dom'
import 'bootstrap/dist/css/bootstrap.css'

const Error = props => {
    return <>
        <h2>{props.error}</h2>
    </>
}
const Spinner = props => {
    return <>
        <h2 style={{ backgroundColor: 'yellow' }}>Loading...</h2>
    </>
}

class Todo extends Component {

    state = {
        error: null,
        isLoaded: false, //spiner status
        todos: [] // data
    }

    render() {
        const { error, isLoaded, todos } = this.state;
        if (error) {
            return <Error error={error} />
        } else if (!isLoaded) {
            return <Spinner />
        } else {
            return <TodoList todos={todos} />
        }

    }
    componentDidMount() {
        const url = 'https://jsonplaceholder.typicode.com/todos'
        fetch(url).then(response => response.json()).then(todos => {
            // console.log(todos)
            setTimeout(() => {
                this.setState(previousState => {
                    return { ...previousState, todos: previousState.todos.concat(todos), isLoaded: true };
                });
            }, 5000)

        }).catch(err => {
            // console.log(err)
            this.setState({
                isLoaded: true,
                err
            });
        });
    }
}

const TodoList = props => {
    const { todos } = props
    return <ul className="list-group">
        {todos.map((todo, index) => (
            <li key={index}>
                <span className="badge badge-pill badge-primary">
                    {todo.id}
                </span>
                <span>
                    {todo.title}
                </span>
            </li>
        ))}
    </ul>
}

const App = () => <div className="container">
    <Todo />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..........................................................................................

..............................................................................................
				 Update
.............................................................................................

Update Phase gets trigger once , the component is mounted into DOM, when user starts interaction like clicking button, typing in the user....

An update can be caused by changes to props or state. These methods are called in the following order when a component is being re-rendered:

static getDerivedStateFromProps() - called both in mount and update cycle
shouldComponentUpdate() -
render()
getSnapshotBeforeUpdate()
componentDidUpdate()


import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'

class ParentComponent extends Component {
    state = {
        i: 0
    }
    //mount phase methods
    constructor() {
        super()
        console.log('Parent Constructor is called')
    }


    render() {
        console.log('Parent render is called')
        return <div>
            <h1>Parent Component</h1>
            <h1>{this.state.i} </h1>
            <button onClick={() => {
                this.setState((oldstate) => ({ ...oldstate, i: oldstate.i + 1 }))
            }}>+</button>
            <ChildComponent {...this.state} />
        </div>
    }

    //after mount
    componentDidMount() {
        console.log('Parent ComponentDidMount is called')
    }
    componentDidUpdate(){
        console.log('Parent componentDidUpdate is called')
    }


}

class ChildComponent extends Component {

    //mount phase methods
    constructor() {
        super()
        console.log('ChildComponent Constructor is called')
    }
    render() {
        console.log('ChildComponent render is called', this.props)

        return <div>
            <h1>Child Component</h1>
        </div>
    }

    componentDidMount() {
        console.log('ChildComponent ComponentDidMount is called')
    }
    componentDidUpdate(){
        console.log('Child componentDidUpdate is called')
    }



}

ReactDOM.render(<ParentComponent />, document.getElementById('root'))

.............................................................................................
				How to prevent to rerender?

shouldComponentUpdate()
 -Which returns true or false
    true means - render method should be called
    false means - render method will not be called

render is called for every ui update,some times i dont want to call render, how to stop calling render method - override shouldComponentUpdate method return false.

when this method is usefull?
 When we want to compare props and state , based on that i want to take decision.
 You want to skip component update based on state and props comparsion.


import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'

class ParentComponent extends Component {
    state = {
        i: 0
    }
    //mount phase methods
    constructor() {
        super()
        console.log('Parent Constructor is called')
    }


    render() {
        console.log('Parent render is called')
        return <div>
            <h1>Parent Component</h1>
            <h1>{this.state.i} </h1>
            <button onClick={() => {
                this.setState((oldstate) => ({ ...oldstate, i: oldstate.i + 1 }))
            }}>+</button>
            <ChildComponent {...this.state} />
        </div>
    }

    //after mount
    componentDidMount() {
        console.log('Parent ComponentDidMount is called')
    }
    componentDidUpdate(){
        console.log('Parent componentDidUpdate is called')
    }


}

class ChildComponent extends Component {

    //mount phase methods
    constructor() {
        super()
        console.log('ChildComponent Constructor is called')
    }
    render() {
        console.log('ChildComponent render is called', this.props)

        return <div>
            <h1>Child Component</h1>
        </div>
    }

    shouldComponentUpdate(){
        return false;
    }

    componentDidMount() {
        console.log('ChildComponent ComponentDidMount is called')
    }
    componentDidUpdate(){
        console.log('Child componentDidUpdate is called')
    }



}

ReactDOM.render(<ParentComponent />, document.getElementById('root'))

..............................................................................................
import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import 'bootstrap/dist/css/bootstrap.css'

class ParentComponent extends Component {
    state = {
        i: 0
    }
    //mount phase methods
    constructor() {
        super()
        console.log('Parent Constructor is called')
    }


    render() {
        console.log('Parent render is called')
        return <div>
            <h1>Parent Component</h1>
            <h1>{this.state.i} </h1>
            <button onClick={() => {
                this.setState((oldstate) => ({ ...oldstate, i: oldstate.i + 1 }))
            }}>+</button>
            <ChildComponent {...this.state} />
        </div>
    }

    //after mount
    componentDidMount() {
        console.log('Parent ComponentDidMount is called')
    }
    componentDidUpdate(){
        console.log('Parent componentDidUpdate is called')
    }


}

class ChildComponent extends React.PureComponent {

    //mount phase methods
    constructor() {
        super()
        console.log('ChildComponent Constructor is called')
    }
    render() {
        console.log('ChildComponent render is called', this.props)

        return <div>
            <h1>Child Component</h1>
        </div>
    }

    // shouldComponentUpdate(){
    //     return false;
    // }

    componentDidMount() {
        console.log('ChildComponent ComponentDidMount is called')
    }
    componentDidUpdate(){
        console.log('Child componentDidUpdate is called')
    }



}

ReactDOM.render(<ParentComponent />, document.getElementById('root'))
..........................................................................................

Should Update code
How to stop rendering components.

YOu can use any logic.
logic can be based on props or state or both

currentState or Next State

currentState:
  state = { 
     counter:0
  }
   what is the current state value -  0
 nextState 
    the state to be computed by setState - button -  counter++ -  1


currentProps or Next prop
 currentProp =1
 NextProp =2
import React from 'react';
import ReactDOM from 'react-dom'

class CounterButton extends React.Component {

    state = { count: 1 };

    shouldComponentUpdate(nextProps, nextState) {
        console.log('Current State=>', this.state)
        console.log("Next State =>", nextState)
        if (nextState.count !== this.state.count) {
            return true
        }
        return false
    }

    render() {
        console.log('render is called')
        return (
            <>
                <button
                    onClick={() => this.setState(state => ({ count: state.count + 1 }))}>
                    Count: {this.state.count}
                </button>
                <button
                    onClick={() => this.setState(state => ({ count: state.count }))}>
                    Count: {this.state.count}
                </button>
            </>
        );
    }
}

class CounterPureButton extends React.PureComponent {

    state = { count: 1 };

    render() {
        console.log('render is called')
        return (
            <>
                <button
                    onClick={() => this.setState(state => ({ count: state.count + 1 }))}>
                    Count: {this.state.count}
                </button>
                <button
                    onClick={() => this.setState(state => ({ count: state.count }))}>
                    Count: {this.state.count}
                </button>
            </>
        );
    }
}
ReactDOM.render(<>
    <h3>Using ComponentShouldUpdate</h3>
    <CounterButton />
    <hr />
    <h3>PureComponent</h3>
    <CounterPureButton />
</>
    , document.getElementById('root'))



.............................................................................................
			  render - vdom,reconcellation process.
............................................................................................
              Second Time/after ui interaction starts
			      User
				 |
			     clicks button (any ui event)
				|
			     listener is called
				|
			     setState() method    
				|
			     render() is called
			        |
			    returns new VDOM
				|
			 Enter into Reconcilation Phase
				|
             diff alogrithm is applied to find right dom nodes to be updated
	
                    compare newVDOM === existing snapshot of dom
				  |
                           finally flush the changes


.............................................................................................
				Component Will UnMount
.............................................................................................

This phase is called once the component is destroyed from the memory.

Unmounting
This method is called when a component is being removed from the DOM:

componentWillUnmount()

There is no method to call and test componentWillUnMount. This method is generally called when We "Routers".

..............................................................................................
				Good bye to class Components
				   Functional Components
..............................................................................................
					Hooks
..............................................................................................


What is hook?
 It is a new feature introduced in react 16.
 Simple abstraction for class compoents-  how to remove classes from react.

Intention is functional component for every things.

objective of hooks:

1.to eleminate class components as much possible.
2.Resuable application behaviours
   eg:ajax calls


Hook is just simple javascript function.
which may take arg or may not.
Which may or may not return something 	


every hook function starts with
  "use"+functionName ==>hook Syntax

eg:
"useState"
"useContext"
"useEffect"
"useAjax"
"useWebSocket"
"useLayout"
etc....
you can create your own hooks as well.

import React, { useState } from 'react'
import ReactDOM from 'react-dom'

class Counter extends React.Component {
    state = {
        value: 0
    }
    onIncrement = evt => {
        this.setState(prevState => ({ ...prevState, value: prevState.value + 1 }))
    }
    render() {
        return <div>
            <h1>Value : {this.state.value}</h1>
            <button onClick={this.onIncrement}>+</button>
        </div>
    }
}

const MyCounter = props => {
    //hook 
    const [counter, setCounter] = useState(0)

    const onIncrement = () => {
        //state update
        // setCounter(oldCounter => {
        //     return oldCounter + 1
        // });
        setCounter(counter + 1);
    }

    return <div>
        <h1>Counter : {counter}</h1>
        <button onClick={onIncrement}>+</button>

    </div>
}


const App = props => <div>
    <h1>Class Component</h1>
    <Counter />
    <hr />
    <h1>Functonal Component-Hook</h1>
    <MyCounter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))


useState:

inital Value:
- can be primitive values , but in state you must wrap inside object
  useState(1) ,useState("") - even though we use primitive behind, the object is used
  state = {
     value:1
     text:""
  }

in Hook
const[value]=  useState(1) ===== > state = {value:1}

You can declare multiple values separatly
import React, { useState } from 'react'
import ReactDOM from 'react-dom'

const Counter = props => {
    const [value1, setValue1] = useState(10)
    const [value2, setValue2] = useState(100)
    
    const onIncrement = () => {
        setValue1(value1 + 1);
    }
    const onDecrement = () => {
        setValue2(value1 - 1);
    }
    return <div>
        <h1>Counter : {value1} {value2}</h1>
        <button onClick={onIncrement}>+</button>
        <button onClick={onDecrement}>-</button>

    </div>
}


const App = props => <div>
    <h1>Functional Component</h1>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
.............................................................................................
import React, { useState } from 'react'
import ReactDOM from 'react-dom'

const Counter = props => {
    let state = { value: 10 };
    const [counter, setCounter] = useState(state)

    const onIncrement = () => {
        setCounter(oldState => {
            console.log(oldState)
            return { ...oldState, value: oldState.value + 1 }
        })
    }


    return <div>
        <h1>Counter : {counter.value}</h1>
        <button onClick={onIncrement}>+</button>

    </div>
}


const App = props => <div>
    <h1>Functional Component</h1>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
...........................................................................................
		   Task : Convert todo class Component app into functional component
..........................................................................................
.............................................................................................
		Component Life Methods and functional Components
.............................................................................................
comonentDidMount:
 Used for doing some resource intensive tasks, such as setting up ajax calls for inital page.
 It is called after inital render

compoentDidUpdate:
  called after every update finishes.

How to write these two life cycle methods inside functional components.

"useEffect" Hook.
  =>can replace both life cycle methods.
mount and update phase
import React, { useEffect, useState } from 'react'
import ReactDOM from 'react-dom'

const Counter = props => {
    let state = { value: 10 };
    const [counter, setCounter] = useState(state)

    const onIncrement = () => {
        setCounter(oldState => {
            console.log(oldState)
            return { ...oldState, value: oldState.value + 1 }
        })
    }
    useEffect(() => {
        console.log('useEffect')
    },[])

    return <div>
        <h1>Counter : {counter.value}</h1>
        <button onClick={onIncrement}>+</button>

    </div>
}


const App = props => <div>
    <h1>Functional Component</h1>
    <Counter />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
import React, { useEffect, useState } from 'react'
import ReactDOM from 'react-dom'

const TodoApi = {
    getAllTodos(url) {
        return fetch(url);
    }
}
const Todos = props => {
    
    const [state, setState] = useState({
        error: null,
        isLoaded: false, //spiner status
        todos: [] // data
    })
    useEffect(() => {
        TodoApi.getAllTodos('https://jsonplaceholder.typicode.com/todos')
            .then(response => response.json())
            .then(todos => {
                setTimeout(() => {
                    setState(prevState => ({ ...prevState, todos: prevState.todos.concat(todos), isLoaded: true }))
                }, 5000)
            })
            .catch(err => {
                setState(prevState => ({ ...prevState, isLoaded: true, error: err }))
            });
    }, [])
    const { error, isLoaded, todos } = state;
    if (error) {
        return <Error error={error} />
    } else if (!isLoaded) {
        return <Spinner />
    } else {
        return <TodoList todos={todos} />
    }
}
const TodoList = props => {
    const { todos } = props
    return <ul className="list-group">
        {todos.map((todo, index) => (
            <li key={index}>
                <span className="badge badge-pill badge-primary">
                    {todo.id}
                </span>
                <span>
                    {todo.title}
                </span>
            </li>
        ))}
    </ul>
}
const Error = props => {
    return <>
        <h2>{props.error}</h2>
    </>
}
const Spinner = props => {
    return <>
        <h2 style={{ backgroundColor: 'yellow' }}>Loading...</h2>
    </>
}

const App = props => <div>
    <h1>Ajax calls inside FuncitionalComponent</h1>
    <Todos />
</div>

ReactDOM.render(<App />, document.getElementById('root'))
..............................................................................................
			  Custom Hooks - How to write resuable code
.............................................................................................


import React, { useEffect, useState } from 'react';
import ReactDOM from 'react-dom';


const CustomerReview = props => {
    const [review, setReview] = useState(1);
    const [screen, setScreen] = useState('Customer Manager App')
    //get Screen size
    const [width, setWidth] = useState(window.innerWidth);

    //Change the screen title once the dom is ready
    useEffect(() => {
        document.title = screen
        //component willUnMount
        return function () {
            console.log('this is called when component is removed')
        }

    })
    useEffect(() => {
        const handleResize = () => setWidth(window.innerWidth)
        //imperative dom listner
        window.addEventListener('resize', handleResize)
        //clean up code
        return () => {
            window.removeEventListener('resize', handleResize);
        }
    })

    const onIncrement = evt => {
        setReview(review + 1)
        setScreen(`${screen} - Review`)
    }
    return <div>
        <h1>Customer Manager App: using Side effects</h1>
        <h1>Screen Width {width}</h1>
        <h1>Review : {review}</h1>
        <button onClick={onIncrement}>PostiveReview</button>
    </div>
}

const App = () => <CustomerReview />

ReactDOM.render(<App />, document.getElementById('root'))


in the above example, we can see there are features

1.Customer review feature
2.screen title feature
3.screen width calculation feature

Here whate are features are tightly coupled with Customer 
 only Review feature

Two are features are highly generic, meaning you can use inside another component as well.

Hooks will help isloate features into separate hook so we can reuse across the application.


src/hooks/useScreenTitle.js
import { useEffect, useState } from 'react';

function useWindowTitle(title = '') {
    const [screen, setScreen] = useState(title)
    //initalize new screen
    useEffect(() => {
        document.title = screen
    })
    //return screen and setScren
    return { screen, setScreen }
}
export { useWindowTitle }

src/hooks/useWindowWidth.js
import { useEffect, useState } from 'react';

//Hooks are not components but you can use component life cycle methods 

const useWindowInnerWidth = () => {
    const [width, setWidth] = useState(window.innerWidth);
    //logic
    useEffect(() => {
        const handleResize = () => setWidth(window.innerWidth)
        //imperative dom listner
        window.addEventListener('resize', handleResize)
        //clean up code
        return () => {
            window.removeEventListener('resize', handleResize);
        }
    });
    return width;

};

export { useWindowInnerWidth };



import React, { useState } from 'react';
import { useWindowTitle } from './hooks/useScreentitle';
import { useWindowInnerWidth } from './hooks/usewindowwidth';
import ReactDOM from 'react-dom';


const CustomerReview = props => {
    const [review, setReview] = useState(1);
    const { screen, setScreen } = useWindowTitle('Customer Manager App')
    const width = useWindowInnerWidth()

    const onIncrement = evt => {
        setReview(review + 1)
        setScreen(`${screen} - Review`)
    }
    return <div>
        <h1>Customer Manager App: using Side effects</h1>
        <h1>Screen Width {width}</h1>
        <h1>Review : {review}</h1>
        <button onClick={onIncrement}>PostiveReview</button>
    </div>
}

const App = () => <CustomerReview />

ReactDOM.render(<App />, document.getElementById('root'))

..............................................................................................				Flux Design Pattern and implementation
..............................................................................................

Flux desing pattern was introduced by facebook in order to build userinterface application.

According to flux design pattern

1.view layer is react
2.state layer is flux.js / redux


				     Redux
.............................................................................................

What is Redux?​
It helps to understand what this "Redux" thing is in the first place.
What does it do?
What problems does it help me solve? 
Why would I want to use it?

Redux is a "pattern and library" for managing and updating application state, using events called "actions".
It serves as a centralized store for state that needs to be used across your entire application, with rules ensuring that the state can only be updated in a predictable fashion.

       In the above defintion you can find out, only one thing in common - "state"

In React we manage state inside component - Statefull component.

if you want to share the data(state) there is only one pattern

Parent ---to---Child Pattern via props

What if i want to share the data across the application 

 Compoent to Component any where in the hierachy -  Redux.
.............................................................................................
				Redux Pattern- Flux Pattern
............................................................................................

Flux is design pattern , created by facebook in order to share the data among the ui(components) with proper channels(flow).

Face book initally designed the flux pattern and implemented this pattern via lib called flux.js

Now a days "flux.js" lib has been deprecated instead we have to use "redux/Mobx"

Flux design pattern has been implemented inside redux.
..............................................................................................
					Flux Pattern

In flux Pattern data is moved in unidirectional flow- one way data flow.

Flux Pattern Components:
.......................

1.View layer
   Just it presents The Application User face.
   React is view

2.State layer
   Flux.js / Redux / Mobx
   It manages the state(data), which maniuplates/updates the state for the entire application.



When Should I Use Redux?​
   Redux helps you deal with shared state management, but like any tool, it has tradeoffs. There are more concepts to learn, and more code to write. It also adds some indirection to your code, and asks you to follow certain restrictions. It's a trade-off between short term and long term productivity.

Redux is more useful when:

1.You have large amounts of application state that are needed in many places in the app
2.The app state is updated frequently over time
3.The logic to update that state may be complex
4.The app has a medium or large-sized codebase, and might be worked on by many people


Redux Terms and Concepts​
........................

1.State Management​:

 The application is composed of different modules(UI).
If you take, Banking Application
 -transaction
 -User screen 
 -Deposit and withdrawal screen

The application state/ app state:
  The data of application, which mimics the database design in the server side apps.

How the database schema has collection of tables ,each table has data related to paricular domain like users,products.

The redux also maintains in memory database schema, which stores the data of UI modules.

                       "Redux stores the app state inside one single literal 
					 Object"


Redux database is "Single javascript literal Object"

eg:
  const appState = {
   
     screen1: {},
     screen2:{},
     screen3:{}     

  }
 const appState = {
   
     transaction: {}, =>Change state===> new AppState => Listener===>View will get fresh State
     user:{},
     accounts:{}     

  }

"one-way data flow":

1.State describes the condition of the app at a specific point in time.
2.The UI is rendered based on that state When something happens (such as a user clicking a button), the state is updated based on what occurred
3.The UI re-renders based on the new state
.............................................................................................

Actions
 An action is a plain JavaScript object that has a "type" field.
 You can think of an action as an event that describes something that happened in the application.

The type field should be a string that gives this action a descriptive name, like "todos/todoAdded".

We usually write that type string like "domain/eventName", where the first part is the feature or category that this action belongs to, and the second part is the specific thing that happened.

An action object can have other fields with additional information about what happened. By convention, we put that information in a field called payload.

syntax:

const increment = {
  type:"counter/increment",
}

const addTodo = {
  type:"todo/addTodo",
  payload : {id:1,text:'learn redux'}

}


Reducers:
   A reducer is a function that receives the current state and an action object, decides how to update the state if necessary, and returns the new state: (state, action) => newState. You can think of a reducer as an event listener which handles events based on the received action (event) type.

 Reducer is a pure function, which is eq to setState or useState in react.

Reducers must always follow some specific rules:

1.They should only calculate the new state value based on the state and action arguments

2.They are not allowed to modify the existing state. Instead, they must make immutable updates, by copying the existing state and making changes to the copied values.
3.They must not do any asynchronous logic, calculate random values, or cause other "side effects"

Syntax:
(state, action) => newState

function counter(state,action){

 switch(action.type){
     case "counter/increment":
 	return {...state,value:state.counter.value + 1}

     default:
        return state;     

 } 

}


Dispatchers /dispatch:
The Redux store has a method called dispatch.
The only way to update the state is to call store.dispatch() and pass in an action object. The store will run its reducer function and save the new state value inside, and we can call getState() to retrieve the updated value

const increment = {
  type:"counter/increment",
}

store.dispatch(increment)=>store.reducer()=>newState=>listener=>react rerender screen


Store:

 Store is object

Role of Store object:
1.stores the app state
2.control communication flows between UI and Redux.

Api:
1.getState()
2.dispatch(action)
3.subscribe(listener)
4.replaceReducer(nextReducer)
...........................................................................................

Redux Level -0:
import { createStore } from "redux";

//reducer - biz logic which is pure function 
const counterReducer = (state = { counter: 0 }, action) => {
//    console.log("Old State /Previous State  =>",state,action)
    //biz logic
    switch (action.type) {
        case 'counter/increment':
            console.log("Old State /Previous State  =>",state,action)
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}

//create Store Object 
const store = createStore(counterReducer);

//bind event listner for store updates, incase any biz logic gets executed.
store.subscribe(()=>{
    console.log("Current State => ",store.getState())
})

//send an action -  send request--- in order to compute new state.
const increment = {
    type:'counter/increment'
}
store.dispatch(increment)
store.dispatch(increment)
store.dispatch(increment)
store.dispatch(increment)
.............................................................................................
			   Redux - React integration
.............................................................................................

in order to connect react with redux we need lib 'react-redux' -  binding lib

import { createStore } from "redux";
import React from 'react';
import ReactDOM from "react-dom"
import { Provider, useDispatch, useSelector } from 'react-redux'

//actions
const incrementAction = {
    type: 'counter/increment'
}

const counterReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case 'counter/increment':
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}
//create Store Object 
const appStore = createStore(counterReducer);
/////////////////////////////////////////////////////////////////////////////////////

//React Component : ready to send request to redux
const Counter = props => {
    const value = useSelector(state => state.counter)
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt=>{
         //we need to send request to redux in order to get new State
        increment(incrementAction);
    }
    return <>
        <h2>Counter App</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}

const App = () => <div>
    <Provider store={appStore}>
        <h1>React - Redux Integration</h1>
        <Counter />
    </Provider>
</div>

ReactDOM.render(<App />, document.getElementById('root'));
.............................................................................................
			       Multiple Reducers
.............................................................................................
import { combineReducers, createStore } from "redux";
import React from 'react';
import ReactDOM from "react-dom"
import { Provider, useDispatch, useSelector } from 'react-redux'

//actions
const incrementAction = {
    type: 'counter/increment'
}
const decrementAction = {
    type: 'counter/decrement'
}

const incrementReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case 'counter/increment':
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}
const decrementReducer = (state = { counter: 100 }, action) => {
    switch (action.type) {
        case 'counter/decrement':
            return { ...state, counter: state.counter - 1 } //immuable object
        default:
            return state;
    }
}

//composition api to compose multiple reducers into one.
const rootReducer = combineReducers({
    increment: incrementReducer,
    decrement: decrementReducer
})

//create Store Object 
const appStore = createStore(rootReducer);


/////////////////////////////////////////////////////////////////////////////////////

//React Component : ready to send request to redux
const Increment = props => {
     //appstate.reducer.state
    const value = useSelector(state => state.increment.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementAction);
    }
    return <>
        <h2>InCrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}
const Decrement = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.decrement.counter) 
    const decrement = useDispatch() // store.dispatch
    //listner
    const onDecrement = evt => {
        //we need to send request to redux in order to get new State
        decrement(decrementAction);
    }
    return <>
        <h2>Decrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onDecrement}>-</button>
    </>
}

const App = () => <div>
    <Provider store={appStore}>
        <h1>React - Redux Integration</h1>
        <Increment />
        <Decrement />
    </Provider>
</div>

ReactDOM.render(<App />, document.getElementById('root'));

............................................................................................
		Action Creators- How to get input from the user and send to Reducer

import { combineReducers, createStore } from "redux";
import React, { useState } from 'react';
import ReactDOM from "react-dom"
import { Provider, useDispatch, useSelector } from 'react-redux'

//actions
const incrementAction = {
    type: 'counter/increment'
}
const decrementAction = {
    type: 'counter/decrement'
}

//action creator : function which returns action object
function incrementByAmountAction(payload) {
    return {
        type: 'counter/incrementByAmount',
        payload
    }
}

const incrementReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case 'counter/increment':
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}
const incrementByAmount = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case 'counter/incrementByAmount':
            return { ...state, counter: state.counter + action.payload } //immuable object
        default:
            return state;
    }
}
const decrementReducer = (state = { counter: 100 }, action) => {
    switch (action.type) {
        case 'counter/decrement':
            return { ...state, counter: state.counter - 1 } //immuable object
        default:
            return state;
    }
}

//composition api to compose multiple reducers into one.
const rootReducer = combineReducers({
    increment: incrementReducer,
    decrement: decrementReducer,
    incrementByAmt: incrementByAmount
})

//create Store Object 
const appStore = createStore(rootReducer);


/////////////////////////////////////////////////////////////////////////////////////

//React Component : ready to send request to redux
const Increment = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.increment.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementAction);
    }
    return <>
        <h2>InCrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}
const IncrementByAmount = props => {
    const [text,setText ] = useState(0);
    //appstate.reducer.state
    const value = useSelector(state => state.incrementByAmt.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementByAmountAction(parseFloat(text)));
    }
    const onUpdate= evt =>{
        setText(evt.target.value)  
     }
    return <>
        <h2>InCrementByAmount Screen</h2>
        <h3>Value : {value}</h3>
        <input onChange={onUpdate} />
        <button onClick={onIncrement}>+</button>
    </>
}
const Decrement = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.decrement.counter)
    const decrement = useDispatch() // store.dispatch
    //listner
    const onDecrement = evt => {
        //we need to send request to redux in order to get new State
        decrement(decrementAction);
    }
    return <>
        <h2>Decrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onDecrement}>-</button>
    </>
}

const App = () => <div>
    <Provider store={appStore}>
        <h1>React - Redux Integration</h1>
        <Increment />
        <IncrementByAmount />
        <Decrement />
    </Provider>
</div>

ReactDOM.render(<App />, document.getElementById('root'));
.............................................................................................	
				Action constants
.............................................................................................

We should not hard code , action names as strings.

"counter/increment"

we have to store in variables 

const INCREMENT = "counter/increment"



import { combineReducers, createStore } from "redux";
import React, { useState } from 'react';
import ReactDOM from "react-dom"
import { Provider, useDispatch, useSelector } from 'react-redux'

//action constants
const INCREMENT = 'counter/increment'
const DECREMENT = 'counter/decrement'
const INCREMENTBYAMOUNT = 'counter/incrementByAmt'

//actions
const incrementAction = {
    type: INCREMENT
}
const decrementAction = {
    type: DECREMENT
}

//action creator : function which returns action object
// function incrementByAmountAction(payload) {
//     return {
//         type: INCREMENTBYAMOUNT,
//         payload
//     }
// }
const incrementByAmountAction = payload => ({
    type: INCREMENTBYAMOUNT,
    payload
})
const incrementReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case INCREMENT:
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}
const incrementByAmount = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case INCREMENTBYAMOUNT:
            return { ...state, counter: state.counter + action.payload } //immuable object
        default:
            return state;
    }
}
const decrementReducer = (state = { counter: 100 }, action) => {
    switch (action.type) {
        case DECREMENT:
            return { ...state, counter: state.counter - 1 } //immuable object
        default:
            return state;
    }
}

//composition api to compose multiple reducers into one.
const rootReducer = combineReducers({
    increment: incrementReducer,
    decrement: decrementReducer,
    incrementByAmt: incrementByAmount
})

//create Store Object 
const appStore = createStore(rootReducer);


/////////////////////////////////////////////////////////////////////////////////////

//React Component : ready to send request to redux
const Increment = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.increment.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementAction);
    }
    return <>
        <h2>InCrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}
const IncrementByAmount = props => {
    const [text, setText] = useState(0);
    //appstate.reducer.state
    const value = useSelector(state => state.incrementByAmt.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementByAmountAction(parseFloat(text)));
    }
    const onUpdate = evt => {
        setText(evt.target.value)
    }
    return <>
        <h2>InCrementByAmount Screen</h2>
        <h3>Value : {value}</h3>
        <input onChange={onUpdate} />
        <button onClick={onIncrement}>+</button>
    </>
}
const Decrement = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.decrement.counter)
    const decrement = useDispatch() // store.dispatch
    //listner
    const onDecrement = evt => {
        //we need to send request to redux in order to get new State
        decrement(decrementAction);
    }
    return <>
        <h2>Decrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onDecrement}>-</button>
    </>
}

const App = () => <div>
    <Provider store={appStore}>
        <h1>React - Redux Integration</h1>
        <Increment />
        <IncrementByAmount />
        <Decrement />
    </Provider>
</div>

ReactDOM.render(<App />, document.getElementById('root'));
.............................................................................................
				Middlewares
.............................................................................................

Middleware is function which gets called before reducer is called.
Middlewares are used for some preprocessing.

Use cases of middlewares:

1.logging
2.asynchronous API calls

Middleware is  higher order function.

General Syntax:

const logger = store => next => action => {
  console.log('dispatching', action)
  let result = next(action)
  console.log('next state', store.getState())
  return result
}

function logger(store){
    return function(next){
         return function(action){
		//middleware code
            let res = next(action);
            return next;
         }
   }

}
store: current store object is passed
next: function which helps to move from the current middleware to next middlewares
action: you can access action object.

With out Middleware:

store.dispatch(action)====>store==>invoke reducer===return state==>listner is called

with middlware

store.dispatch(action)== M1--M2--M3--MN ==>==>invoke reducer===return state==>listner is called

in order to integrate middleware work flow, redux offers applyMiddleware function,which need to passed as parameter to the createStore function

Logger Middleware
import { applyMiddleware, combineReducers, createStore } from "redux";
import React, { useState } from 'react';
import ReactDOM from "react-dom"
import { Provider, useDispatch, useSelector } from 'react-redux'

//action constants
const INCREMENT = 'counter/increment'
const DECREMENT = 'counter/decrement'
const INCREMENTBYAMOUNT = 'counter/incrementByAmt'

//actions
const incrementAction = {
    type: INCREMENT
}
const decrementAction = {
    type: DECREMENT
}

//action creator : function which returns action object
// function incrementByAmountAction(payload) {
//     return {
//         type: INCREMENTBYAMOUNT,
//         payload
//     }
// }
const incrementByAmountAction = payload => ({
    type: INCREMENTBYAMOUNT,
    payload
})
const incrementReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case INCREMENT:
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}
const incrementByAmount = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case INCREMENTBYAMOUNT:
            return { ...state, counter: state.counter + action.payload } //immuable object
        default:
            return state;
    }
}
const decrementReducer = (state = { counter: 100 }, action) => {
    switch (action.type) {
        case DECREMENT:
            return { ...state, counter: state.counter - 1 } //immuable object
        default:
            return state;
    }
}

//composition api to compose multiple reducers into one.
const rootReducer = combineReducers({
    increment: incrementReducer,
    decrement: decrementReducer,
    incrementByAmt: incrementByAmount
})

//custom middlewares

const logger = store => next => action => {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
}

//create Store Object 
const appStore = createStore(rootReducer, applyMiddleware(logger));


/////////////////////////////////////////////////////////////////////////////////////

//React Component : ready to send request to redux
const Increment = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.increment.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementAction);
    }
    return <>
        <h2>InCrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}
const IncrementByAmount = props => {
    const [text, setText] = useState(0);
    //appstate.reducer.state
    const value = useSelector(state => state.incrementByAmt.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementByAmountAction(parseFloat(text)));
    }
    const onUpdate = evt => {
        setText(evt.target.value)
    }
    return <>
        <h2>InCrementByAmount Screen</h2>
        <h3>Value : {value}</h3>
        <input onChange={onUpdate} />
        <button onClick={onIncrement}>+</button>
    </>
}
const Decrement = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.decrement.counter)
    const decrement = useDispatch() // store.dispatch
    //listner
    const onDecrement = evt => {
        //we need to send request to redux in order to get new State
        decrement(decrementAction);
    }
    return <>
        <h2>Decrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onDecrement}>-</button>
    </>
}

const App = () => <div>
    <Provider store={appStore}>
        <h1>React - Redux Integration</h1>
        <Increment />
        <IncrementByAmount />
        <Decrement />
    </Provider>
</div>

ReactDOM.render(<App />, document.getElementById('root'));
..............................................................................................
				Ajax code and Redux

import { applyMiddleware, combineReducers, createStore } from "redux";
import React, { useState,useEffect } from 'react';
import ReactDOM from "react-dom"
import { Provider, useDispatch, useSelector } from 'react-redux'
import thunk from 'redux-thunk'

//action constants
const INCREMENT = 'counter/increment'
const DECREMENT = 'counter/decrement'
const INCREMENTBYAMOUNT = 'counter/incrementByAmt'

//actions
const incrementAction = {
    type: INCREMENT
}
const decrementAction = {
    type: DECREMENT
}

//action creator : function which returns action object
// function incrementByAmountAction(payload) {
//     return {
//         type: INCREMENTBYAMOUNT,
//         payload
//     }
// }
const incrementByAmountAction = payload => ({
    type: INCREMENTBYAMOUNT,
    payload
})
const incrementReducer = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case INCREMENT:
            return { ...state, counter: state.counter + 1 } //immuable object
        default:
            return state;
    }
}
const incrementByAmount = (state = { counter: 10 }, action) => {
    switch (action.type) {
        case INCREMENTBYAMOUNT:
            return { ...state, counter: state.counter + action.payload } //immuable object
        default:
            return state;
    }
}
const decrementReducer = (state = { counter: 100 }, action) => {
    switch (action.type) {
        case DECREMENT:
            return { ...state, counter: state.counter - 1 } //immuable object
        default:
            return state;
    }
}

const todosReducer = (state = [], action) => {
    switch (action.type) {
        case 'todos':
            return state.concat(action.payload)
        default:
            return state;
    }
}
//composition api to compose multiple reducers into one.
const rootReducer = combineReducers({
    increment: incrementReducer,
    decrement: decrementReducer,
    incrementByAmt: incrementByAmount,
    todos:todosReducer
})

//custom middlewares
const logger = store => next => action => {
    console.log('dispatching', action)
    let result = next(action)
    console.log('next state', store.getState())
    return result
}


//todo action creator
function todocreator(todos) {
    return {
        type: 'todos',
        payload: todos
    }
}
//ajax logic
function todosAsync() {
    return dispatch => {
        fetch('https://jsonplaceholder.typicode.com/todos').then(res => {
            res.json().then(todos => {
                dispatch(todocreator(todos));
            });
        })
    }
}

//create Store Object 
const appStore = createStore(rootReducer, applyMiddleware(logger,thunk));


/////////////////////////////////////////////////////////////////////////////////////

//React Component : ready to send request to redux
const Increment = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.increment.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementAction);
    }
    return <>
        <h2>InCrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}
const IncrementByAmount = props => {
    const [text, setText] = useState(0);
    //appstate.reducer.state
    const value = useSelector(state => state.incrementByAmt.counter) //state
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        //we need to send request to redux in order to get new State
        increment(incrementByAmountAction(parseFloat(text)));
    }
    const onUpdate = evt => {
        setText(evt.target.value)
    }
    return <>
        <h2>InCrementByAmount Screen</h2>
        <h3>Value : {value}</h3>
        <input onChange={onUpdate} />
        <button onClick={onIncrement}>+</button>
    </>
}
const Decrement = props => {
    //appstate.reducer.state
    const value = useSelector(state => state.decrement.counter)
    const decrement = useDispatch() // store.dispatch
    //listner
    const onDecrement = evt => {
        //we need to send request to redux in order to get new State
        decrement(decrementAction);
    }
    return <>
        <h2>Decrement Screen</h2>
        <h3>Value : {value}</h3>
        <button onClick={onDecrement}>-</button>
    </>
}

//todos component which gets data via redux
const Todos = props => {
    const todos = useSelector(state => state.todos);
    const getTodos = useDispatch();
    useEffect(() => {
        getTodos(todosAsync())
    }, [])
    return <div>
        <h1>Todos App</h1>
        <ul>
            {todos.map(todo => <li key={todo.id}>
                <span>{todo.title}</span>
            </li>)}
        </ul>
    </div>
}


const App = () => <div>
    <Provider store={appStore}>
        <h1>React - Redux Integration</h1>
        <Increment />
        <IncrementByAmount />
        <Decrement />
        <Todos/>
    </Provider>
</div>

ReactDOM.render(<App />, document.getElementById('root'));

......................................................................................
				App Structure in the react-redux
.....................................................................................

Recommended Project Structure

/src
   index.js: the starting point for the app
   App.js: the top-level React component
/app
  store.js: creates the Redux store instance
/features
   /counter
      Counter.js: a React component that shows the UI for the counter feature
      counterReducer.js: the Redux logic for the counter feature
..............................................................................................
			  Advanced Redux -  Redux toolkit - with Typescript
.............................................................................................

React Router :

Step -0: Home Page
import React from 'react';
import ReactDOM from 'react-dom'
import { Provider } from 'react-redux';
import { BrowserRouter, Route, Routes, Link, Outlet } from 'react-router-dom';
import { appStore } from './app/store';
import { Counter } from './counter/counter';

const Home = () => <h1>Home</h1>
const About = () => <h1>About</h1>
const Dashboard = () => <h1>Dashboard</h1>
const Transactions = () => <h1>Transactions</h1>

const Layout = () => {
    return (
        <div>
            {/* A "layout route" is a good place to put markup you want to
            share across all the pages on your site, like navigation. */}
            <nav>
                <ul>
                    <li>
                        <Link to="/">Home</Link>
                    </li>
                    <li>
                        <Link to="/about">About</Link>
                    </li>
                    <li>
                        <Link to="/dashboard">Dashboard</Link>
                    </li>
                    <li>
                        <Link to="/transcations">Transactions</Link>
                    </li>
                    <li>
                        <Link to="/counter">Redux-Counter</Link>
                    </li>
                </ul>
            </nav>

            <hr />

            {/* An <Outlet> renders whatever child route is currently active,
            so you can think about this <Outlet> as a placeholder for
            the child routes we defined above. */}
            <Outlet />
        </div>
    );
}



const App = props => {
    return <Provider store={appStore} >
        <BrowserRouter>
            <Routes>
                <Route path="/" element={<Layout />}>
                    {/* Child routes */}
                    <Route index element={<Home />} />
                    <Route path="about" element={<About />} />
                    <Route path="dashboard" element={<Dashboard />} />
                    <Route path="transcations" element={<Transactions />} />
                    <Route path="counter" element = {<Counter/>}/>
                </Route>
            </Routes>
        </BrowserRouter>
    </Provider>
}

ReactDOM.render(<App />, document.getElementById('root'))

////////////////////////

src/app/store.js
import { createStore, combineReducers } from 'redux'
import { counterReducer } from '../counter/counterreducer'


const rootReducer = combineReducers({
    counter: counterReducer
})

const appStore = createStore(rootReducer)

export { appStore };
/////////////////////////////////////////////////////////////////////////////////

src/counter/counterreducer.js


const counterReducer = (state = { value: 0 }, action) => {
    switch (action.type) {
        case 'counter/increment':
            return { ...state, value: state.value + 1 }
        default:
            return state;
    }
}
export {counterReducer }

src/counter/counter.jsx
import React, { useEffect } from 'react';
import { useSelector, useDispatch } from 'react-redux';

const Counter = props => {
    const value = useSelector(state => state.counter.value)
    const increment = useDispatch() // store.dispatch
    //listner
    const onIncrement = evt => {
        increment({ type: 'counter/increment' });
    }
    useEffect(()=>{
        console.log('counter init')
        //componentwillUnMount
        return function(){
            console.log('counter destroyed')
        }
    },[])
    return <>
        <h2>Counter App</h2>
        <h3>Value : {value}</h3>
        <button onClick={onIncrement}>+</button>
    </>
}
export { Counter };
..............................XXXXXXXXXXXXXXXXXXXXXXX.......................................













